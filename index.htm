<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Viewer</title>
    <link rel="stylesheet" href="style.css">
    <script src="fractals/mandelbrot.js"></script>
    <script src="fractals/julia.js"></script>
    <script src="fractals/burning-ship.js"></script>
    <script src="fractals/koch.js"></script>
    <script src="fractals/sierpinski.js"></script>
    <script src="fractals/dragon.js"></script>
    <script src="fractals/barnsley.js"></script>
    <script src="fractals/menger.js"></script>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="menu">
        <h2>Fractal Viewer</h2>
        
        <div class="menu-section">
            <label>Fractal Type</label>
            <select id="fractalType">
                <option value="mandelbrot">Mandelbrot Set</option>
                <option value="burning_ship">Burning Ship</option>
                <option value="julia">Julia Set</option>
                <option value="koch">Koch Snowflake</option>
                <option value="sierpinski">Sierpinski Triangle</option>
                <option value="dragon">Dragon Curve</option>
                <option value="barnsley">Barnsley Fern</option>
                <option value="menger">Menger Sponge</option>
            </select>
        </div>

        <div class="menu-section" id="juliaControls" style="display: none;">
            <label>Julia Set Preset</label>
            <select id="juliaPreset">
                <option value="dendrite">Dendrite (-0.4 + 0.6i)</option>
                <option value="san_marco">San Marco (-0.75 + 0.1i)</option>
                <option value="spiral">Spiral (-0.7269 + 0.1889i)</option>
                <option value="dragon">Dragon (-0.835 - 0.2321i)</option>
                <option value="douady">Douady Rabbit (-0.123 + 0.745i)</option>
                <option value="siegel">Siegel Disk (-0.391 - 0.587i)</option>
                <option value="custom">Custom Parameters</option>
            </select>
            
            <button id="juliaClickBtn" style="width: 100%; margin-top: 10px; background: #9C27B0;">
                Click Mandelbrot to Set Julia
            </button>
        </div>

        <div class="menu-section" id="mandelbrotControls" style="display: none;">
            <button id="mandelbrotClickBtn" style="width: 100%; background: #9C27B0;">
                Click to Pick Julia Parameter
            </button>
            <div id="clickModeIndicator" style="display: none; margin-top: 8px; padding: 8px; background: rgba(156, 39, 176, 0.1); border-radius: 4px; font-size: 11px; color: #9C27B0; text-align: center;">
                Click anywhere on the fractal
            </div>
        </div>

        <div class="menu-section" id="juliaParams" style="display: none;">
            <label>Real Part (c_real)</label>
            <input type="number" id="juliaReal" value="-0.8" step="0.001" min="-2" max="2">
            <label style="margin-top: 8px;">Imaginary Part (c_imag)</label>
            <input type="number" id="juliaImag" value="0.156" step="0.001" min="-2" max="2">
        </div>

        <div class="menu-section">
            <label>Max Iterations</label>
            <input type="number" id="maxIterations" value="100" min="10" max="1000" step="10">
        </div>

        <div class="menu-section">
            <label>Color Scheme</label>
            <select id="colorScheme">
                <option value="default">Default (Polynomial)</option>
                <option value="cosine">Cosine Gradient (Custom)</option>
                <option value="continuous">Continuous (HSL)</option>
                <option value="hsl">HSL Interpolation</option>
                <option value="golden">Golden Ratio</option>
                <option value="cubehelix">Cubehelix</option>
                <option value="grayscale">Grayscale</option>
                <option value="bezier">Bezier RGB</option>
                <option value="complementary">Complementary</option>
                <option value="triadic">Triadic</option>
                <option value="stripe">Stripe Averaging</option>
            </select>
        </div>

        <div class="menu-section" id="cosineControls" style="display: none;">
            <label style="margin-bottom: 10px; display: block;">Base Color</label>
            <div style="display: flex; gap: 8px; align-items: center;">
                <input type="color" id="cosineBaseColor" value="#8080ff" style="flex: 1; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                <div id="cosineBasePreview" style="width: 35px; height: 35px; border-radius: 4px; background: #8080ff; border: 2px solid #ddd;"></div>
            </div>
            
            <label style="margin-top: 12px; margin-bottom: 10px; display: block;">Accent Color</label>
            <div style="display: flex; gap: 8px; align-items: center;">
                <input type="color" id="cosineAccentColor" value="#ff8080" style="flex: 1; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                <div id="cosineAccentPreview" style="width: 35px; height: 35px; border-radius: 4px; background: #ff8080; border: 2px solid #ddd;"></div>
            </div>
        </div>

        <div class="menu-section" id="hslControls" style="display: none;">
            <label>Start Hue (0-360°)</label>
            <input type="range" id="hslStartHue" min="0" max="360" value="240" style="width: 100%;">
            <span id="hslStartHueValue" style="font-size: 11px; color: #666;">240°</span>
            
            <label style="margin-top: 8px;">End Hue (0-360°)</label>
            <input type="range" id="hslEndHue" min="0" max="360" value="0" style="width: 100%;">
            <span id="hslEndHueValue" style="font-size: 11px; color: #666;">0°</span>
        </div>

        <div class="menu-section" id="bezierControls" style="display: none;">
            <label style="margin-bottom: 8px; display: block;">Color Points</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <div>
                    <label style="font-size: 10px; color: #666;">Start</label>
                    <div style="display: flex; gap: 4px;">
                        <input type="color" id="bezierColor0" value="#0a1464" style="flex: 1; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                        <div id="bezierPreview0" style="width: 30px; height: 30px; border-radius: 4px; background: #0a1464; border: 1px solid #ddd;"></div>
                    </div>
                </div>
                <div>
                    <label style="font-size: 10px; color: #666;">Point 1</label>
                    <div style="display: flex; gap: 4px;">
                        <input type="color" id="bezierColor1" value="#0096c8" style="flex: 1; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                        <div id="bezierPreview1" style="width: 30px; height: 30px; border-radius: 4px; background: #0096c8; border: 1px solid #ddd;"></div>
                    </div>
                </div>
                <div>
                    <label style="font-size: 10px; color: #666;">Point 2</label>
                    <div style="display: flex; gap: 4px;">
                        <input type="color" id="bezierColor2" value="#ffdc32" style="flex: 1; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                        <div id="bezierPreview2" style="width: 30px; height: 30px; border-radius: 4px; background: #ffdc32; border: 1px solid #ddd;"></div>
                    </div>
                </div>
                <div>
                    <label style="font-size: 10px; color: #666;">End</label>
                    <div style="display: flex; gap: 4px;">
                        <input type="color" id="bezierColor3" value="#c8320a" style="flex: 1; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                        <div id="bezierPreview3" style="width: 30px; height: 30px; border-radius: 4px; background: #c8320a; border: 1px solid #ddd;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="menu-section" id="complementaryControls" style="display: none;">
            <label>Base Hue (0-360°)</label>
            <input type="range" id="complementaryHue" min="0" max="360" value="220" style="width: 100%;">
            <span id="complementaryHueValue" style="font-size: 11px; color: #666;">220°</span>
        </div>

        <div class="menu-section" id="triadicControls" style="display: none;">
            <label>Base Hue (0-360°)</label>
            <input type="range" id="triadicHue" min="0" max="360" value="0" style="width: 100%;">
            <span id="triadicHueValue" style="font-size: 11px; color: #666;">0°</span>
        </div>

        <div class="menu-section" id="cubehelixControls" style="display: none;">
            <label>Rotations</label>
            <input type="range" id="cubehelixRotations" min="-3" max="3" step="0.1" value="-1.5" style="width: 100%;">
            <span id="cubehelixRotationsValue" style="font-size: 11px; color: #666;">-1.5</span>
        </div>

        <div class="button-group">
            <button id="resetBtn" class="secondary">Reset View</button>
            <button id="renderBtn">Render</button>
        </div>

        <div class="info">
            Left-click and drag to zoom box<br>
            Right-click and drag to pan<br>
            Scroll to zoom<br>
            Double-click to zoom in
        </div>
    </div>

    <div class="loading" id="loading">
        <div id="loadingText">Rendering...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">0%</div>
    </div>

    <script>
        class FractalViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');

                // Initialize fractal instances
                this.fractals = {
                    mandelbrot: new MandelbrotFractal(this),
                    julia: new JuliaFractal(this),
                    burning_ship: new BurningShipFractal(this),
                    koch: new KochFractal(this),
                    sierpinski: new SierpinskiFractal(this),
                    dragon: new DragonFractal(this),
                    barnsley: new BarnsleyFractal(this),
                    menger: new MengerFractal(this)
                };

                this.loading = document.getElementById('loading');
                this.progressFill = document.getElementById('progressFill');
                this.progressText = document.getElementById('progressText');

                // Fractal parameters
                this.fractalType = 'mandelbrot';
                this.centerX = -0.5;
                this.centerY = 0;
                this.zoom = 1;
                this.maxIterations = 100;
                this.colorScheme = 'default';
                
                // Click-to-Julia mode
                this.juliaClickMode = false;
                
                // Cosine gradient colors
                this.cosineBaseColor = { r: 128, g: 128, b: 255 }; // Purple-blue
                this.cosineAccentColor = { r: 255, g: 128, b: 128 }; // Pink-red
                
                // HSL parameters
                this.hslStartHue = 240;
                this.hslEndHue = 0;
                
                // Bezier parameters
                this.bezierColors = [
                    { r: 10, g: 20, b: 100 },
                    { r: 0, g: 150, b: 200 },
                    { r: 255, g: 220, b: 50 },
                    { r: 200, g: 50, b: 10 }
                ];
                
                // Complementary/Triadic base hues
                this.complementaryHue = 220;
                this.triadicHue = 0;
                
                // Cubehelix rotations
                this.cubehelixRotations = -1.5;
                
                // Julia Set parameters
                this.juliaReal = -0.4;
                this.juliaImag = 0.6;
                
                // Julia Set presets
                this.juliaPresets = {
                    dendrite: { real: -0.4, imag: 0.6, name: 'Dendrite' },
                    san_marco: { real: -0.75, imag: 0.1, name: 'San Marco' },
                    spiral: { real: -0.7269, imag: 0.1889, name: 'Spiral' },
                    dragon: { real: -0.835, imag: -0.2321, name: 'Dragon' },
                    douady: { real: -0.123, imag: 0.745, name: 'Douady Rabbit' },
                    siegel: { real: -0.391, imag: -0.587, name: 'Siegel Disk' }
                };
                
                // Mouse interaction
                this.isDragging = false;
                this.isZoomBoxing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.zoomBoxStart = { x: 0, y: 0 };
                this.zoomBoxEnd = { x: 0, y: 0 };
                this.savedImageData = null; // For storing canvas state during zoom box
                
                // Debounce timers for color controls
                this.colorDebounceTimer = null;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.render();
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.render();
                });

                // Mouse dragging for panning and zoom box
                this.canvas.addEventListener('mousedown', (e) => {
                    // Right-click or Ctrl+Click for panning
                    if (e.button === 2 || e.ctrlKey) {
                        e.preventDefault();
                        this.isDragging = true;
                        this.lastX = e.clientX;
                        this.lastY = e.clientY;
                    } 
                    // Left-click for zoom box or Julia parameter selection
                    else if (e.button === 0 && !e.ctrlKey) {
                        // Check if in Julia click mode
                        if (this.juliaClickMode && this.fractalType === 'mandelbrot') {
                            this.handleJuliaClick(e.clientX, e.clientY);
                        } else {
                            this.isZoomBoxing = true;
                            this.zoomBoxStart.x = e.clientX;
                            this.zoomBoxStart.y = e.clientY;
                            this.zoomBoxEnd.x = e.clientX;
                            this.zoomBoxEnd.y = e.clientY;
                            // Save current canvas state
                            this.savedImageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                        }
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const dx = e.clientX - this.lastX;
                        const dy = e.clientY - this.lastY;
                        
                        const scale = 3.5 / (this.zoom * this.canvas.width);
                        this.centerX -= dx * scale;
                        this.centerY -= dy * scale;
                        
                        this.lastX = e.clientX;
                        this.lastY = e.clientY;
                        
                        this.render();
                    } else if (this.isZoomBoxing) {
                        this.zoomBoxEnd.x = e.clientX;
                        this.zoomBoxEnd.y = e.clientY;
                        // Restore saved image and draw zoom box
                        this.ctx.putImageData(this.savedImageData, 0, 0);
                        this.drawZoomBox();
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.isZoomBoxing && e.button === 0) {
                        this.isZoomBoxing = false;
                        this.savedImageData = null;
                        this.executeZoomBox();
                    }
                    this.isDragging = false;
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    if (this.isZoomBoxing) {
                        // Restore canvas if zoom box was cancelled
                        if (this.savedImageData) {
                            this.ctx.putImageData(this.savedImageData, 0, 0);
                        }
                        this.isZoomBoxing = false;
                        this.savedImageData = null;
                    }
                });

                // Prevent context menu on right-click
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // Mouse wheel for zooming
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    
                    // Get world coordinates before zoom
                    const worldX = this.screenToWorldX(mouseX);
                    const worldY = this.screenToWorldY(mouseY);
                    
                    // Zoom
                    this.zoom *= zoomFactor;
                    
                    // Get world coordinates after zoom
                    const newWorldX = this.screenToWorldX(mouseX);
                    const newWorldY = this.screenToWorldY(mouseY);
                    
                    // Adjust center to keep mouse position fixed
                    this.centerX += worldX - newWorldX;
                    this.centerY += worldY - newWorldY;
                    
                    this.render();
                });

                // Double-click to zoom in
                this.canvas.addEventListener('dblclick', (e) => {
                    const worldX = this.screenToWorldX(e.clientX);
                    const worldY = this.screenToWorldY(e.clientY);
                    
                    this.centerX = worldX;
                    this.centerY = worldY;
                    this.zoom *= 2;
                    
                    this.render();
                });

                // Menu controls
                document.getElementById('fractalType').addEventListener('change', (e) => {
                    this.fractalType = e.target.value;
                    this.updateJuliaControls();
                    this.updateCosineControls();
                    this.resetView();
                    this.render();
                });

                // Julia click mode buttons
                const mandelbrotClickBtn = document.getElementById('mandelbrotClickBtn');
                const juliaClickBtn = document.getElementById('juliaClickBtn');
                const clickModeIndicator = document.getElementById('clickModeIndicator');

                if (mandelbrotClickBtn) {
                    mandelbrotClickBtn.addEventListener('click', () => {
                        this.juliaClickMode = !this.juliaClickMode;
                        if (this.juliaClickMode) {
                            mandelbrotClickBtn.classList.add('active');
                            mandelbrotClickBtn.textContent = 'Click Mode: ON';
                            clickModeIndicator.style.display = 'block';
                        } else {
                            mandelbrotClickBtn.classList.remove('active');
                            mandelbrotClickBtn.textContent = 'Click to Pick Julia Parameter';
                            clickModeIndicator.style.display = 'none';
                        }
                    });
                }

                if (juliaClickBtn) {
                    juliaClickBtn.addEventListener('click', () => {
                        // Switch to Mandelbrot and enable click mode
                        this.fractalType = 'mandelbrot';
                        document.getElementById('fractalType').value = 'mandelbrot';
                        this.juliaClickMode = true;
                        this.updateJuliaControls();
                        this.resetView();
                        this.render();
                    });
                }

                document.getElementById('juliaPreset').addEventListener('change', (e) => {
                    const preset = e.target.value;
                    if (preset !== 'custom' && this.juliaPresets[preset]) {
                        this.juliaReal = this.juliaPresets[preset].real;
                        this.juliaImag = this.juliaPresets[preset].imag;
                        document.getElementById('juliaReal').value = this.juliaReal;
                        document.getElementById('juliaImag').value = this.juliaImag;
                        document.getElementById('juliaParams').style.display = 'none';
                    } else {
                        document.getElementById('juliaParams').style.display = 'block';
                    }
                    this.render();
                });

                document.getElementById('juliaReal').addEventListener('input', (e) => {
                    this.juliaReal = parseFloat(e.target.value);
                    document.getElementById('juliaPreset').value = 'custom';
                });
                document.getElementById('juliaReal').addEventListener('change', (e) => {
                    this.render();
                });

                document.getElementById('juliaImag').addEventListener('input', (e) => {
                    this.juliaImag = parseFloat(e.target.value);
                    document.getElementById('juliaPreset').value = 'custom';
                });
                document.getElementById('juliaImag').addEventListener('change', (e) => {
                    this.render();
                });

                document.getElementById('maxIterations').addEventListener('change', (e) => {
                    this.maxIterations = parseInt(e.target.value);
                    this.render();
                });

                document.getElementById('colorScheme').addEventListener('change', (e) => {
                    this.colorScheme = e.target.value;
                    this.updateCosineControls();
                    this.render();
                });

                document.getElementById('cosineBaseColor').addEventListener('input', (e) => {
                    const hex = e.target.value;
                    this.cosineBaseColor = this.hexToRgb(hex);
                    document.getElementById('cosineBasePreview').style.background = hex;
                    this.debouncedRender();
                });

                document.getElementById('cosineAccentColor').addEventListener('input', (e) => {
                    const hex = e.target.value;
                    this.cosineAccentColor = this.hexToRgb(hex);
                    document.getElementById('cosineAccentPreview').style.background = hex;
                    this.debouncedRender();
                });

                // HSL controls
                document.getElementById('hslStartHue').addEventListener('input', (e) => {
                    this.hslStartHue = parseInt(e.target.value);
                    document.getElementById('hslStartHueValue').textContent = this.hslStartHue + '°';
                });
                document.getElementById('hslStartHue').addEventListener('change', (e) => {
                    this.render();
                });

                document.getElementById('hslEndHue').addEventListener('input', (e) => {
                    this.hslEndHue = parseInt(e.target.value);
                    document.getElementById('hslEndHueValue').textContent = this.hslEndHue + '°';
                });
                document.getElementById('hslEndHue').addEventListener('change', (e) => {
                    this.render();
                });

                // Bezier controls
                for (let i = 0; i < 4; i++) {
                    document.getElementById(`bezierColor${i}`).addEventListener('input', (e) => {
                        this.bezierColors[i] = this.hexToRgb(e.target.value);
                        document.getElementById(`bezierPreview${i}`).style.background = e.target.value;
                        this.debouncedRender();
                    });
                }

                // Complementary control
                document.getElementById('complementaryHue').addEventListener('input', (e) => {
                    this.complementaryHue = parseInt(e.target.value);
                    document.getElementById('complementaryHueValue').textContent = this.complementaryHue + '°';
                });
                document.getElementById('complementaryHue').addEventListener('change', (e) => {
                    this.render();
                });

                // Triadic control
                document.getElementById('triadicHue').addEventListener('input', (e) => {
                    this.triadicHue = parseInt(e.target.value);
                    document.getElementById('triadicHueValue').textContent = this.triadicHue + '°';
                });
                document.getElementById('triadicHue').addEventListener('change', (e) => {
                    this.render();
                });

                // Cubehelix control
                document.getElementById('cubehelixRotations').addEventListener('input', (e) => {
                    this.cubehelixRotations = parseFloat(e.target.value);
                    document.getElementById('cubehelixRotationsValue').textContent = this.cubehelixRotations.toFixed(1);
                });
                document.getElementById('cubehelixRotations').addEventListener('change', (e) => {
                    this.render();
                });

                document.getElementById('renderBtn').addEventListener('click', () => {
                    this.render();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetView();
                    this.render();
                });
            }

            updateJuliaControls() {
                const juliaControls = document.getElementById('juliaControls');
                const juliaParams = document.getElementById('juliaParams');
                const mandelbrotControls = document.getElementById('mandelbrotControls');
                const mandelbrotClickBtn = document.getElementById('mandelbrotClickBtn');
                const clickModeIndicator = document.getElementById('clickModeIndicator');
                
                if (this.fractalType === 'julia') {
                    juliaControls.style.display = 'block';
                    mandelbrotControls.style.display = 'none';
                    // Show params only if custom is selected
                    const preset = document.getElementById('juliaPreset').value;
                    juliaParams.style.display = preset === 'custom' ? 'block' : 'none';
                } else if (this.fractalType === 'mandelbrot') {
                    juliaControls.style.display = 'none';
                    mandelbrotControls.style.display = 'block';
                    // Update button state
                    if (this.juliaClickMode) {
                        mandelbrotClickBtn.classList.add('active');
                        mandelbrotClickBtn.textContent = 'Click Mode: ON';
                        clickModeIndicator.style.display = 'block';
                    } else {
                        mandelbrotClickBtn.classList.remove('active');
                        mandelbrotClickBtn.textContent = 'Click to Pick Julia Parameter';
                        clickModeIndicator.style.display = 'none';
                    }
                } else {
                    juliaControls.style.display = 'none';
                    juliaParams.style.display = 'none';
                    mandelbrotControls.style.display = 'none';
                }
            }

            updateCosineControls() {
                // Hide all color control sections
                document.getElementById('cosineControls').style.display = 'none';
                document.getElementById('hslControls').style.display = 'none';
                document.getElementById('bezierControls').style.display = 'none';
                document.getElementById('complementaryControls').style.display = 'none';
                document.getElementById('triadicControls').style.display = 'none';
                document.getElementById('cubehelixControls').style.display = 'none';
                
                // Show relevant controls based on scheme
                switch(this.colorScheme) {
                    case 'cosine':
                        document.getElementById('cosineControls').style.display = 'block';
                        break;
                    case 'hsl':
                        document.getElementById('hslControls').style.display = 'block';
                        break;
                    case 'bezier':
                        document.getElementById('bezierControls').style.display = 'block';
                        break;
                    case 'complementary':
                        document.getElementById('complementaryControls').style.display = 'block';
                        break;
                    case 'triadic':
                        document.getElementById('triadicControls').style.display = 'block';
                        break;
                    case 'cubehelix':
                        document.getElementById('cubehelixControls').style.display = 'block';
                        break;
                }
            }

            handleJuliaClick(screenX, screenY) {
                // Convert screen coordinates to Mandelbrot coordinates
                const worldX = this.screenToWorldX(screenX);
                const worldY = this.screenToWorldY(screenY);
                
                // Set Julia parameters to clicked point
                this.juliaReal = worldX;
                this.juliaImag = worldY;
                
                // Update UI
                document.getElementById('juliaReal').value = this.juliaReal.toFixed(4);
                document.getElementById('juliaImag').value = this.juliaImag.toFixed(4);
                document.getElementById('juliaPreset').value = 'custom';
                
                // Switch to Julia set
                this.fractalType = 'julia';
                document.getElementById('fractalType').value = 'julia';
                
                // Disable click mode
                this.juliaClickMode = false;
                
                // Update UI and render
                this.updateJuliaControls();
                this.resetView();
                this.render();
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 128, g: 128, b: 255 };
            }

            debouncedRender(delay = 150) {
                // Clear existing timer
                if (this.colorDebounceTimer) {
                    clearTimeout(this.colorDebounceTimer);
                }
                // Set new timer
                this.colorDebounceTimer = setTimeout(() => {
                    this.render();
                }, delay);
            }

            updateProgress(percent) {
                this.progressFill.style.width = percent + '%';
                this.progressText.textContent = Math.floor(percent) + '%';
            }

            resetView() {
                if (this.fractalType === 'mandelbrot') {
                    this.centerX = -0.5;
                    this.centerY = 0;
                    this.zoom = 1;
                } else if (this.fractalType === 'burning_ship') {
                    this.centerX = -0.5;
                    this.centerY = -0.5;
                    this.zoom = 1.2;
                } else if (this.fractalType === 'julia') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                } else if (this.fractalType === 'koch') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                } else if (this.fractalType === 'sierpinski') {
                    this.centerX = 0;
                    this.centerY = 0.1;
                    this.zoom = 1.8;
                } else if (this.fractalType === 'dragon') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 2.5;
                } else if (this.fractalType === 'barnsley') {
                    this.centerX = 0;
                    this.centerY = -0.2;
                    this.zoom = 1.2;
                } else if (this.fractalType === 'menger') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                }
            }

            drawZoomBox() {
                // Draw the zoom box overlay without re-rendering the fractal
                const x1 = Math.min(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                const y1 = Math.min(this.zoomBoxStart.y, this.zoomBoxEnd.y);
                const width = Math.abs(this.zoomBoxEnd.x - this.zoomBoxStart.x);
                const height = Math.abs(this.zoomBoxEnd.y - this.zoomBoxStart.y);

                // Just draw the box overlay directly on top of existing canvas
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeRect(x1, y1, width, height);
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.fillRect(x1, y1, width, height);
                
                this.ctx.setLineDash([]);
            }

            executeZoomBox() {
                const x1 = Math.min(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                const y1 = Math.min(this.zoomBoxStart.y, this.zoomBoxEnd.y);
                const x2 = Math.max(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                const y2 = Math.max(this.zoomBoxStart.y, this.zoomBoxEnd.y);

                const width = x2 - x1;
                const height = y2 - y1;

                // Ignore very small boxes (likely accidental clicks)
                if (width < 10 || height < 10) {
                    this.render();
                    return;
                }

                // Calculate the center of the zoom box in world coordinates
                const centerScreenX = (x1 + x2) / 2;
                const centerScreenY = (y1 + y2) / 2;
                
                const newCenterX = this.screenToWorldX(centerScreenX);
                const newCenterY = this.screenToWorldY(centerScreenY);

                // Calculate the zoom factor based on the box size
                const zoomFactorX = this.canvas.width / width;
                const zoomFactorY = this.canvas.height / height;
                const zoomFactor = Math.min(zoomFactorX, zoomFactorY);

                // Update view
                this.centerX = newCenterX;
                this.centerY = newCenterY;
                this.zoom *= zoomFactor;

                this.render();
            }

            screenToWorldX(screenX) {
                const scale = 3.5 / (this.zoom * this.canvas.width);
                return this.centerX + (screenX - this.canvas.width / 2) * scale;
            }

            screenToWorldY(screenY) {
                const scale = 3.5 / (this.zoom * this.canvas.width);
                return this.centerY + (screenY - this.canvas.height / 2) * scale;
            }

            getColor(iteration) {
                if (iteration >= this.maxIterations) {
                    return [0, 0, 0];
                }

                switch(this.colorScheme) {
                    case 'default':
                        return this.getColorDefault(iteration);
                    case 'cosine':
                        return this.getColorCosine(iteration);
                    case 'continuous':
                        return this.getColorContinuous(iteration);
                    case 'hsl':
                        return this.getColorHSL(iteration);
                    case 'golden':
                        return this.getColorGolden(iteration);
                    case 'cubehelix':
                        return this.getColorCubehelix(iteration);
                    case 'grayscale':
                        return this.getColorGrayscale(iteration);
                    case 'bezier':
                        return this.getColorBezier(iteration);
                    case 'complementary':
                        return this.getColorComplementary(iteration);
                    case 'triadic':
                        return this.getColorTriadic(iteration);
                    case 'stripe':
                        return this.getColorStripe(iteration);
                    default:
                        return this.getColorDefault(iteration);
                }
            }

            getColorDefault(iteration) {
                // Original polynomial coloring
                const t = iteration / this.maxIterations;
                const r = Math.floor(9 * (1 - t) * t * t * t * 255);
                const g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
                const b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);
                return [r, g, b];
            }

            getColorCosine(iteration) {
                // Cosine gradient using user-selected base and accent colors
                const t = iteration / this.maxIterations;
                
                // Convert user colors to normalized values (0-1 range)
                const base = {
                    r: this.cosineBaseColor.r / 255,
                    g: this.cosineBaseColor.g / 255,
                    b: this.cosineBaseColor.b / 255
                };
                
                const accent = {
                    r: this.cosineAccentColor.r / 255,
                    g: this.cosineAccentColor.g / 255,
                    b: this.cosineAccentColor.b / 255
                };
                
                // Calculate midpoint and amplitude for cosine function
                // a = midpoint between base and accent
                // b = half the distance between them (amplitude)
                const a = [
                    (base.r + accent.r) / 2,
                    (base.g + accent.g) / 2,
                    (base.b + accent.b) / 2
                ];
                
                const b = [
                    (accent.r - base.r) / 2,
                    (accent.g - base.g) / 2,
                    (accent.b - base.b) / 2
                ];
                
                // Use cosine function with configurable frequency
                const c = [1.0, 1.0, 1.0]; // Frequency
                const d = [0.0, 0.33, 0.67]; // Phase shift for each channel

                const r = Math.floor(255 * (a[0] + b[0] * Math.cos(2 * Math.PI * (c[0] * t + d[0]))));
                const g = Math.floor(255 * (a[1] + b[1] * Math.cos(2 * Math.PI * (c[1] * t + d[1]))));
                const b_val = Math.floor(255 * (a[2] + b[2] * Math.cos(2 * Math.PI * (c[2] * t + d[2]))));

                return [
                    Math.max(0, Math.min(255, r)),
                    Math.max(0, Math.min(255, g)),
                    Math.max(0, Math.min(255, b_val))
                ];
            }

            getColorContinuous(iteration) {
                // Continuous coloring using smooth iteration count
                // Slower hue cycling and modulated saturation/lightness for smoother appearance
                
                // Slow down the hue change significantly
                const hue = (iteration * 3) % 360;
                
                // Vary saturation and lightness based on iteration for depth
                // This creates more organic, less jarring transitions
                const saturation = 70 + 30 * Math.sin(iteration * 0.1);
                const lightness = 40 + 20 * Math.cos(iteration * 0.15);
                
                return this.hslToRgb(hue, saturation, lightness);
            }

            hslToRgb(h, s, l) {
                h = h / 360;
                s = s / 100;
                l = l / 100;

                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            getColorHSL(iteration) {
                // HSL interpolation with customizable start and end hues
                const t = iteration / this.maxIterations;
                const hue = this.hslStartHue + (this.hslEndHue - this.hslStartHue) * t;
                const saturation = 80;
                const lightness = 50;
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorGolden(iteration) {
                // Golden ratio based hue distribution
                const phi = 1.618033988749895; // Golden ratio
                const hue = (iteration * phi * 137.508) % 360; // Golden angle
                const saturation = 70;
                const lightness = 50;
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorCubehelix(iteration) {
                // Cubehelix color scheme with customizable rotations
                const t = iteration / this.maxIterations;
                const start = 0.5; // Start hue
                const hue = 360 * (start / 3 + this.cubehelixRotations * t);
                const saturation = 50 + 50 * t;
                const lightness = 20 + 60 * t; // Monotonically increasing
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorGrayscale(iteration) {
                // Simple grayscale with smooth gradation
                const t = iteration / this.maxIterations;
                const intensity = Math.floor(255 * Math.sqrt(t));
                return [intensity, intensity, intensity];
            }

            getColorBezier(iteration) {
                // Bezier curve interpolation through customizable RGB control points
                const t = iteration / this.maxIterations;
                
                const p0 = this.bezierColors[0];
                const p1 = this.bezierColors[1];
                const p2 = this.bezierColors[2];
                const p3 = this.bezierColors[3];

                // Cubic Bezier interpolation
                const s = 1 - t;
                const r = s*s*s * p0.r + 3*s*s*t * p1.r + 3*s*t*t * p2.r + t*t*t * p3.r;
                const g = s*s*s * p0.g + 3*s*s*t * p1.g + 3*s*t*t * p2.g + t*t*t * p3.g;
                const b = s*s*s * p0.b + 3*s*s*t * p1.b + 3*s*t*t * p2.b + t*t*t * p3.b;

                return [Math.floor(r), Math.floor(g), Math.floor(b)];
            }

            getColorComplementary(iteration) {
                // Complementary color harmony with customizable base hue
                const t = iteration / this.maxIterations;
                // Oscillate between complementary colors
                const hue = t < 0.5 ? this.complementaryHue : (this.complementaryHue + 180) % 360;
                const saturation = 80;
                const lightness = 40 + 20 * Math.sin(t * Math.PI * 4);
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorTriadic(iteration) {
                // Triadic color harmony with customizable base hue
                const t = iteration / this.maxIterations;
                let hue;
                if (t < 0.33) {
                    hue = this.triadicHue;
                } else if (t < 0.66) {
                    hue = (this.triadicHue + 120) % 360;
                } else {
                    hue = (this.triadicHue + 240) % 360;
                }
                const saturation = 70;
                const lightness = 45 + 15 * Math.sin(t * Math.PI * 6);
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorStripe(iteration) {
                // Stripe averaging effect - creates interesting banding
                const t = iteration / this.maxIterations;
                // Create color bands with smooth transitions
                const bands = 8;
                const bandIndex = Math.floor(t * bands);
                const bandT = (t * bands) - bandIndex;

                const hue = (bandIndex * 45) % 360;
                const saturation = 70 + 20 * Math.sin(bandT * Math.PI);
                const lightness = 40 + 20 * bandT;

                return this.hslToRgb(hue, saturation, lightness);
            }

            async render() {
                this.loading.classList.add('active');
                this.updateProgress(0);
                
                // Small delay to allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));

                const width = this.canvas.width;
                const height = this.canvas.height;

                if (this.fractalType === 'mandelbrot') {
                    await this.fractals.mandelbrot.render();
                } else if (this.fractalType === 'burning_ship') {
                    await this.fractals.burning_ship.render();
                } else if (this.fractalType === 'julia') {
                    await this.fractals.julia.render();
                } else if (this.fractalType === 'koch') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    await new Promise(resolve => setTimeout(resolve, 0));
                    this.fractals.koch.render();
                    this.updateProgress(100);
                } else if (this.fractalType === 'sierpinski') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    await new Promise(resolve => setTimeout(resolve, 0));
                    this.fractals.sierpinski.render();
                    this.updateProgress(100);
                } else if (this.fractalType === 'dragon') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    await new Promise(resolve => setTimeout(resolve, 0));
                    this.fractals.dragon.render();
                    this.updateProgress(100);
                } else if (this.fractalType === 'barnsley') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    await new Promise(resolve => setTimeout(resolve, 0));
                    this.fractals.barnsley.render();
                    this.updateProgress(100);
                } else if (this.fractalType === 'menger') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    await new Promise(resolve => setTimeout(resolve, 0));
                    this.fractals.menger.render();
                    this.updateProgress(100);
                }

                this.loading.classList.remove('active');
            }

            worldToScreenX(worldX) {
                const scale = this.zoom * this.canvas.width / 3.5;
                return (worldX - this.centerX) * scale + this.canvas.width / 2;
            }

            worldToScreenY(worldY) {
                const scale = this.zoom * this.canvas.width / 3.5;
                return (worldY - this.centerY) * scale + this.canvas.height / 2;
            }
        }

        // Initialize the viewer when page loads
        window.addEventListener('load', () => {
            new FractalViewer();
        });
    </script>
</body>
</html>
