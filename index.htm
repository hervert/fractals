<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .menu {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            z-index: 1000;
        }

        .menu h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #333;
        }

        .menu-section {
            margin-bottom: 15px;
        }

        .menu-section:last-child {
            margin-bottom: 0;
        }

        .menu-section label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .menu-section select,
        .menu-section input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        button {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: 500;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #2196F3;
        }

        button.secondary:hover {
            background: #0b7dda;
        }

        .info {
            font-size: 11px;
            color: #888;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            min-width: 250px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .loading.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-top: 12px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 4px;
        }

        .progress-text {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="menu">
        <h2>Fractal Viewer</h2>
        
        <div class="menu-section">
            <label>Fractal Type</label>
            <select id="fractalType">
                <option value="mandelbrot">Mandelbrot Set</option>
                <option value="julia">Julia Set</option>
                <option value="koch">Koch Snowflake</option>
                <option value="sierpinski">Sierpinski Triangle</option>
                <option value="dragon">Dragon Curve</option>
                <option value="barnsley">Barnsley Fern</option>
                <option value="menger">Menger Sponge</option>
            </select>
        </div>

        <div class="menu-section" id="juliaControls" style="display: none;">
            <label>Julia Set Preset</label>
            <select id="juliaPreset">
                <option value="ship">Ghost Ship (-0.8 + 0.156i)</option>
                <option value="dendrite">Dendrite (-0.4 + 0.6i)</option>
                <option value="spiral">Spiral (-0.7269 + 0.1889i)</option>
                <option value="dragon">Dragon (-0.835 - 0.2321i)</option>
                <option value="douady">Douady Rabbit (-0.123 + 0.745i)</option>
                <option value="siegel">Siegel Disk (-0.391 - 0.587i)</option>
                <option value="custom">Custom Parameters</option>
            </select>
        </div>

        <div class="menu-section" id="juliaParams" style="display: none;">
            <label>Real Part (c_real)</label>
            <input type="number" id="juliaReal" value="-0.8" step="0.001" min="-2" max="2">
            <label style="margin-top: 8px;">Imaginary Part (c_imag)</label>
            <input type="number" id="juliaImag" value="0.156" step="0.001" min="-2" max="2">
        </div>

        <div class="menu-section">
            <label>Max Iterations</label>
            <input type="number" id="maxIterations" value="100" min="10" max="1000" step="10">
        </div>

        <div class="menu-section">
            <label>Color Scheme</label>
            <select id="colorScheme">
                <option value="default">Default (Polynomial)</option>
                <option value="cosine1">Cosine Gradient 1</option>
                <option value="cosine2">Cosine Gradient 2 (Fire)</option>
                <option value="cosine3">Cosine Gradient 3 (Ocean)</option>
                <option value="cosine4">Cosine Gradient 4 (Rainbow)</option>
                <option value="continuous">Continuous Coloring</option>
            </select>
        </div>

        <div class="button-group">
            <button id="resetBtn" class="secondary">Reset View</button>
            <button id="renderBtn">Render</button>
        </div>

        <div class="info">
            Left-click and drag to zoom box<br>
            Right-click and drag to pan<br>
            Scroll to zoom<br>
            Double-click to zoom in
        </div>
    </div>

    <div class="loading" id="loading">
        <div id="loadingText">Rendering...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">0%</div>
    </div>

    <script>
        class FractalViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.progressFill = document.getElementById('progressFill');
                this.progressText = document.getElementById('progressText');
                
                // Fractal parameters
                this.fractalType = 'mandelbrot';
                this.centerX = -0.5;
                this.centerY = 0;
                this.zoom = 1;
                this.maxIterations = 100;
                this.colorScheme = 'default';
                
                // Julia Set parameters
                this.juliaReal = -0.8;
                this.juliaImag = 0.156;
                
                // Julia Set presets
                this.juliaPresets = {
                    ship: { real: -0.8, imag: 0.156, name: 'Ghost Ship' },
                    dendrite: { real: -0.4, imag: 0.6, name: 'Dendrite' },
                    spiral: { real: -0.7269, imag: 0.1889, name: 'Spiral' },
                    dragon: { real: -0.835, imag: -0.2321, name: 'Dragon' },
                    douady: { real: -0.123, imag: 0.745, name: 'Douady Rabbit' },
                    siegel: { real: -0.391, imag: -0.587, name: 'Siegel Disk' }
                };
                
                // Mouse interaction
                this.isDragging = false;
                this.isZoomBoxing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.zoomBoxStart = { x: 0, y: 0 };
                this.zoomBoxEnd = { x: 0, y: 0 };
                
                this.setupCanvas();
                this.setupEventListeners();
                this.render();
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.render();
                });

                // Mouse dragging for panning and zoom box
                this.canvas.addEventListener('mousedown', (e) => {
                    // Right-click or Ctrl+Click for panning
                    if (e.button === 2 || e.ctrlKey) {
                        e.preventDefault();
                        this.isDragging = true;
                        this.lastX = e.clientX;
                        this.lastY = e.clientY;
                    } 
                    // Left-click for zoom box
                    else if (e.button === 0 && !e.ctrlKey) {
                        this.isZoomBoxing = true;
                        this.zoomBoxStart.x = e.clientX;
                        this.zoomBoxStart.y = e.clientY;
                        this.zoomBoxEnd.x = e.clientX;
                        this.zoomBoxEnd.y = e.clientY;
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const dx = e.clientX - this.lastX;
                        const dy = e.clientY - this.lastY;
                        
                        const scale = 3.5 / (this.zoom * this.canvas.width);
                        this.centerX -= dx * scale;
                        this.centerY -= dy * scale;
                        
                        this.lastX = e.clientX;
                        this.lastY = e.clientY;
                        
                        this.render();
                    } else if (this.isZoomBoxing) {
                        this.zoomBoxEnd.x = e.clientX;
                        this.zoomBoxEnd.y = e.clientY;
                        this.drawZoomBox();
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.isZoomBoxing && e.button === 0) {
                        this.isZoomBoxing = false;
                        this.executeZoomBox();
                    }
                    this.isDragging = false;
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    if (this.isZoomBoxing) {
                        this.isZoomBoxing = false;
                        this.render();
                    }
                });

                // Prevent context menu on right-click
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // Mouse wheel for zooming
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    
                    // Get world coordinates before zoom
                    const worldX = this.screenToWorldX(mouseX);
                    const worldY = this.screenToWorldY(mouseY);
                    
                    // Zoom
                    this.zoom *= zoomFactor;
                    
                    // Get world coordinates after zoom
                    const newWorldX = this.screenToWorldX(mouseX);
                    const newWorldY = this.screenToWorldY(mouseY);
                    
                    // Adjust center to keep mouse position fixed
                    this.centerX += worldX - newWorldX;
                    this.centerY += worldY - newWorldY;
                    
                    this.render();
                });

                // Double-click to zoom in
                this.canvas.addEventListener('dblclick', (e) => {
                    const worldX = this.screenToWorldX(e.clientX);
                    const worldY = this.screenToWorldY(e.clientY);
                    
                    this.centerX = worldX;
                    this.centerY = worldY;
                    this.zoom *= 2;
                    
                    this.render();
                });

                // Menu controls
                document.getElementById('fractalType').addEventListener('change', (e) => {
                    this.fractalType = e.target.value;
                    this.updateJuliaControls();
                    this.resetView();
                    this.render();
                });

                document.getElementById('juliaPreset').addEventListener('change', (e) => {
                    const preset = e.target.value;
                    if (preset !== 'custom' && this.juliaPresets[preset]) {
                        this.juliaReal = this.juliaPresets[preset].real;
                        this.juliaImag = this.juliaPresets[preset].imag;
                        document.getElementById('juliaReal').value = this.juliaReal;
                        document.getElementById('juliaImag').value = this.juliaImag;
                        document.getElementById('juliaParams').style.display = 'none';
                    } else {
                        document.getElementById('juliaParams').style.display = 'block';
                    }
                    this.render();
                });

                document.getElementById('juliaReal').addEventListener('input', (e) => {
                    this.juliaReal = parseFloat(e.target.value);
                    document.getElementById('juliaPreset').value = 'custom';
                    this.render();
                });

                document.getElementById('juliaImag').addEventListener('input', (e) => {
                    this.juliaImag = parseFloat(e.target.value);
                    document.getElementById('juliaPreset').value = 'custom';
                    this.render();
                });

                document.getElementById('maxIterations').addEventListener('change', (e) => {
                    this.maxIterations = parseInt(e.target.value);
                });

                document.getElementById('colorScheme').addEventListener('change', (e) => {
                    this.colorScheme = e.target.value;
                    this.render();
                });

                document.getElementById('renderBtn').addEventListener('click', () => {
                    this.render();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetView();
                    this.render();
                });
            }

            updateJuliaControls() {
                const juliaControls = document.getElementById('juliaControls');
                const juliaParams = document.getElementById('juliaParams');
                
                if (this.fractalType === 'julia') {
                    juliaControls.style.display = 'block';
                    // Show params only if custom is selected
                    const preset = document.getElementById('juliaPreset').value;
                    juliaParams.style.display = preset === 'custom' ? 'block' : 'none';
                } else {
                    juliaControls.style.display = 'none';
                    juliaParams.style.display = 'none';
                }
            }

            updateProgress(percent) {
                this.progressFill.style.width = percent + '%';
                this.progressText.textContent = Math.floor(percent) + '%';
            }

            resetView() {
                if (this.fractalType === 'mandelbrot') {
                    this.centerX = -0.5;
                    this.centerY = 0;
                    this.zoom = 1;
                } else if (this.fractalType === 'julia') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                } else if (this.fractalType === 'koch') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                } else if (this.fractalType === 'sierpinski') {
                    this.centerX = 0;
                    this.centerY = 0.1;
                    this.zoom = 1.8;
                } else if (this.fractalType === 'dragon') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 2.5;
                } else if (this.fractalType === 'barnsley') {
                    this.centerX = 0;
                    this.centerY = -0.2;
                    this.zoom = 1.2;
                } else if (this.fractalType === 'menger') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                }
            }

            drawZoomBox() {
                // Redraw the current fractal
                this.render().then(() => {
                    // Draw the zoom box overlay
                    const x1 = Math.min(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                    const y1 = Math.min(this.zoomBoxStart.y, this.zoomBoxEnd.y);
                    const width = Math.abs(this.zoomBoxEnd.x - this.zoomBoxStart.x);
                    const height = Math.abs(this.zoomBoxEnd.y - this.zoomBoxStart.y);

                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(x1, y1, width, height);
                    
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.fillRect(x1, y1, width, height);
                    
                    this.ctx.setLineDash([]);
                });
            }

            executeZoomBox() {
                const x1 = Math.min(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                const y1 = Math.min(this.zoomBoxStart.y, this.zoomBoxEnd.y);
                const x2 = Math.max(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                const y2 = Math.max(this.zoomBoxStart.y, this.zoomBoxEnd.y);

                const width = x2 - x1;
                const height = y2 - y1;

                // Ignore very small boxes (likely accidental clicks)
                if (width < 10 || height < 10) {
                    this.render();
                    return;
                }

                // Calculate the center of the zoom box in world coordinates
                const centerScreenX = (x1 + x2) / 2;
                const centerScreenY = (y1 + y2) / 2;
                
                const newCenterX = this.screenToWorldX(centerScreenX);
                const newCenterY = this.screenToWorldY(centerScreenY);

                // Calculate the zoom factor based on the box size
                const zoomFactorX = this.canvas.width / width;
                const zoomFactorY = this.canvas.height / height;
                const zoomFactor = Math.min(zoomFactorX, zoomFactorY);

                // Update view
                this.centerX = newCenterX;
                this.centerY = newCenterY;
                this.zoom *= zoomFactor;

                this.render();
            }

            screenToWorldX(screenX) {
                const scale = 3.5 / (this.zoom * this.canvas.width);
                return this.centerX + (screenX - this.canvas.width / 2) * scale;
            }

            screenToWorldY(screenY) {
                const scale = 3.5 / (this.zoom * this.canvas.width);
                return this.centerY + (screenY - this.canvas.height / 2) * scale;
            }

            mandelbrot(cx, cy) {
                let x = 0;
                let y = 0;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < this.maxIterations) {
                    const xtemp = x * x - y * y + cx;
                    y = 2 * x * y + cy;
                    x = xtemp;
                    iteration++;
                }

                // For continuous coloring, add smooth component
                if (iteration < this.maxIterations) {
                    const log_zn = Math.log(x * x + y * y) / 2;
                    const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                    iteration = iteration + 1 - nu;
                }

                return iteration;
            }

            julia(zx, zy) {
                let x = zx;
                let y = zy;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < this.maxIterations) {
                    const xtemp = x * x - y * y + this.juliaReal;
                    y = 2 * x * y + this.juliaImag;
                    x = xtemp;
                    iteration++;
                }

                // For continuous coloring, add smooth component
                if (iteration < this.maxIterations) {
                    const log_zn = Math.log(x * x + y * y) / 2;
                    const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                    iteration = iteration + 1 - nu;
                }

                return iteration;
            }

            getColor(iteration) {
                if (iteration >= this.maxIterations) {
                    return [0, 0, 0];
                }

                if (this.colorScheme === 'default') {
                    return this.getColorDefault(iteration);
                } else if (this.colorScheme.startsWith('cosine')) {
                    return this.getColorCosine(iteration);
                } else if (this.colorScheme === 'continuous') {
                    return this.getColorContinuous(iteration);
                }
                
                return this.getColorDefault(iteration);
            }

            getColorDefault(iteration) {
                // Original polynomial coloring
                const t = iteration / this.maxIterations;
                const r = Math.floor(9 * (1 - t) * t * t * t * 255);
                const g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
                const b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);
                return [r, g, b];
            }

            getColorCosine(iteration) {
                // Cosine gradient: color = a + b * cos(2Ï€ * (c * t + d))
                // Different presets for different color schemes
                const t = iteration / this.maxIterations;
                
                let a, b, c, d;
                
                if (this.colorScheme === 'cosine1') {
                    // Purple and blue tones
                    a = [0.5, 0.5, 0.5];
                    b = [0.5, 0.5, 0.5];
                    c = [1.0, 1.0, 1.0];
                    d = [0.0, 0.33, 0.67];
                } else if (this.colorScheme === 'cosine2') {
                    // Fire colors
                    a = [0.5, 0.5, 0.5];
                    b = [0.5, 0.5, 0.5];
                    c = [1.0, 1.0, 1.0];
                    d = [0.0, 0.10, 0.20];
                } else if (this.colorScheme === 'cosine3') {
                    // Ocean colors
                    a = [0.5, 0.5, 0.5];
                    b = [0.5, 0.5, 0.5];
                    c = [1.0, 1.0, 1.0];
                    d = [0.30, 0.20, 0.20];
                } else if (this.colorScheme === 'cosine4') {
                    // Rainbow
                    a = [0.5, 0.5, 0.5];
                    b = [0.5, 0.5, 0.5];
                    c = [2.0, 1.0, 0.0];
                    d = [0.50, 0.20, 0.25];
                }

                const r = Math.floor(255 * (a[0] + b[0] * Math.cos(2 * Math.PI * (c[0] * t + d[0]))));
                const g = Math.floor(255 * (a[1] + b[1] * Math.cos(2 * Math.PI * (c[1] * t + d[1]))));
                const b_val = Math.floor(255 * (a[2] + b[2] * Math.cos(2 * Math.PI * (c[2] * t + d[2]))));

                return [
                    Math.max(0, Math.min(255, r)),
                    Math.max(0, Math.min(255, g)),
                    Math.max(0, Math.min(255, b_val))
                ];
            }

            getColorContinuous(iteration) {
                // Continuous coloring using smooth iteration count
                // Slower hue cycling and modulated saturation/lightness for smoother appearance
                
                // Slow down the hue change significantly
                const hue = (iteration * 3) % 360;
                
                // Vary saturation and lightness based on iteration for depth
                // This creates more organic, less jarring transitions
                const saturation = 70 + 30 * Math.sin(iteration * 0.1);
                const lightness = 40 + 20 * Math.cos(iteration * 0.15);
                
                return this.hslToRgb(hue, saturation, lightness);
            }

            hslToRgb(h, s, l) {
                h = h / 360;
                s = s / 100;
                l = l / 100;

                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            // Koch Snowflake methods
            kochSegment(x1, y1, x2, y2, depth) {
                if (depth === 0) {
                    return [[x1, y1], [x2, y2]];
                }

                const dx = x2 - x1;
                const dy = y2 - y1;

                // First third point
                const px1 = x1 + dx / 3;
                const py1 = y1 + dy / 3;

                // Second third point
                const px2 = x1 + 2 * dx / 3;
                const py2 = y1 + 2 * dy / 3;

                // Peak point (equilateral triangle)
                const angle = Math.PI / 3; // 60 degrees
                const px3 = px1 + (px2 - px1) * Math.cos(angle) - (py2 - py1) * Math.sin(angle);
                const py3 = py1 + (px2 - px1) * Math.sin(angle) + (py2 - py1) * Math.cos(angle);

                // Recursively generate segments
                const seg1 = this.kochSegment(x1, y1, px1, py1, depth - 1);
                const seg2 = this.kochSegment(px1, py1, px3, py3, depth - 1);
                const seg3 = this.kochSegment(px3, py3, px2, py2, depth - 1);
                const seg4 = this.kochSegment(px2, py2, x2, y2, depth - 1);

                // Concatenate all segments
                const result = seg1.slice(0, -1)
                    .concat(seg2.slice(0, -1))
                    .concat(seg3.slice(0, -1))
                    .concat(seg4);

                return result;
            }

            generateKochSnowflake(depth) {
                // Equilateral triangle vertices
                const size = 0.8;
                const height = size * Math.sqrt(3) / 2;
                
                const v1 = [-size / 2, height / 3];
                const v2 = [size / 2, height / 3];
                const v3 = [0, -2 * height / 3];

                // Generate each side of the snowflake
                const side1 = this.kochSegment(v1[0], v1[1], v2[0], v2[1], depth);
                const side2 = this.kochSegment(v2[0], v2[1], v3[0], v3[1], depth);
                const side3 = this.kochSegment(v3[0], v3[1], v1[0], v1[1], depth);

                // Concatenate all sides
                return side1.slice(0, -1)
                    .concat(side2.slice(0, -1))
                    .concat(side3.slice(0, -1));
            }

            // Sierpinski Triangle methods
            generateSierpinskiTriangle(depth) {
                const triangles = [];
                const size = 0.8;
                const height = size * Math.sqrt(3) / 2;

                // Initial triangle
                const v1 = [-size / 2, height / 3];
                const v2 = [size / 2, height / 3];
                const v3 = [0, -2 * height / 3];

                this.subdivideTriangle(v1, v2, v3, depth, triangles);
                return triangles;
            }

            subdivideTriangle(v1, v2, v3, depth, triangles) {
                if (depth === 0) {
                    triangles.push([v1, v2, v3]);
                    return;
                }

                // Midpoints
                const m1 = [(v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2];
                const m2 = [(v2[0] + v3[0]) / 2, (v2[1] + v3[1]) / 2];
                const m3 = [(v3[0] + v1[0]) / 2, (v3[1] + v1[1]) / 2];

                // Recursively subdivide the three outer triangles
                this.subdivideTriangle(v1, m1, m3, depth - 1, triangles);
                this.subdivideTriangle(m1, v2, m2, depth - 1, triangles);
                this.subdivideTriangle(m3, m2, v3, depth - 1, triangles);
            }

            // Dragon Curve methods
            generateDragonCurve(depth) {
                let sequence = [1]; // Start with a single right turn
                
                // Build the dragon curve sequence
                for (let i = 0; i < depth; i++) {
                    const newSequence = [...sequence];
                    newSequence.push(1); // Add a right turn
                    // Add reversed and flipped sequence
                    for (let j = sequence.length - 1; j >= 0; j--) {
                        newSequence.push(-sequence[j]);
                    }
                    sequence = newSequence;
                }

                // Convert sequence to points
                const points = [[0, 0]];
                let x = 0, y = 0;
                let direction = 0; // 0 = right, 1 = up, 2 = left, 3 = down
                const stepSize = 0.4 / Math.pow(Math.sqrt(2), depth);

                for (const turn of sequence) {
                    direction = (direction + turn + 4) % 4;
                    
                    switch (direction) {
                        case 0: x += stepSize; break; // right
                        case 1: y -= stepSize; break; // up
                        case 2: x -= stepSize; break; // left
                        case 3: y += stepSize; break; // down
                    }
                    
                    points.push([x, y]);
                }

                return points;
            }

            // Barnsley Fern methods
            generateBarnsleyFern(iterations) {
                const points = [];
                let x = 0, y = 0;

                for (let i = 0; i < iterations; i++) {
                    const r = Math.random();
                    let nextX, nextY;

                    if (r < 0.01) {
                        // Stem
                        nextX = 0;
                        nextY = 0.16 * y;
                    } else if (r < 0.86) {
                        // Successively smaller leaflets
                        nextX = 0.85 * x + 0.04 * y;
                        nextY = -0.04 * x + 0.85 * y + 1.6;
                    } else if (r < 0.93) {
                        // Largest left-hand leaflet
                        nextX = 0.2 * x - 0.26 * y;
                        nextY = 0.23 * x + 0.22 * y + 1.6;
                    } else {
                        // Largest right-hand leaflet
                        nextX = -0.15 * x + 0.28 * y;
                        nextY = 0.26 * x + 0.24 * y + 0.44;
                    }

                    x = nextX;
                    y = nextY;

                    // Skip first few iterations (transient behavior)
                    if (i > 20) {
                        points.push([x / 11, y / 11 - 0.5]); // Normalize to fit view
                    }
                }

                return points;
            }

            // Menger Sponge methods (2D cross-section)
            generateMengerSponge(depth) {
                const squares = [];
                this.subdivideMengerSquare(0, 0, 0.8, depth, squares);
                return squares;
            }

            subdivideMengerSquare(x, y, size, depth, squares) {
                if (depth === 0) {
                    squares.push({ x, y, size });
                    return;
                }

                const newSize = size / 3;

                // Divide into 9 squares, skip the middle one
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        // Skip center square
                        if (i === 1 && j === 1) continue;

                        const newX = x + (i - 1) * newSize;
                        const newY = y + (j - 1) * newSize;
                        this.subdivideMengerSquare(newX, newY, newSize, depth - 1, squares);
                    }
                }
            }

            async render() {
                this.loading.classList.add('active');
                this.updateProgress(0);
                
                // Small delay to allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));

                const width = this.canvas.width;
                const height = this.canvas.height;

                // Don't clear canvas - keep previous fractal visible while rendering

                if (this.fractalType === 'mandelbrot') {
                    await this.renderMandelbrot();
                } else if (this.fractalType === 'julia') {
                    await this.renderJulia();
                } else if (this.fractalType === 'koch') {
                    // Clear for geometric fractals
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderKoch();
                    this.updateProgress(100);
                } else if (this.fractalType === 'sierpinski') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderSierpinski();
                    this.updateProgress(100);
                } else if (this.fractalType === 'dragon') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderDragon();
                    this.updateProgress(100);
                } else if (this.fractalType === 'barnsley') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderBarnsley();
                    this.updateProgress(100);
                } else if (this.fractalType === 'menger') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderMenger();
                    this.updateProgress(100);
                }

                this.loading.classList.remove('active');
            }

            async renderMandelbrot() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const imageData = this.ctx.createImageData(width, height);
                const data = imageData.data;

                const scale = 3.5 / (this.zoom * width);
                const chunkSize = 20; // Update progress every 20 rows

                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const x0 = this.centerX + (px - width / 2) * scale;
                        const y0 = this.centerY + (py - height / 2) * scale;

                        const iteration = this.mandelbrot(x0, y0);
                        const [r, g, b] = this.getColor(iteration);

                        const index = (py * width + px) * 4;
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                        data[index + 3] = 255;
                    }

                    // Update progress but DON'T draw to canvas yet
                    if (py % chunkSize === 0) {
                        const progress = (py / height) * 100;
                        this.updateProgress(progress);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                this.updateProgress(100);
                // Draw complete image all at once
                this.ctx.putImageData(imageData, 0, 0);
            }

            async renderJulia() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const imageData = this.ctx.createImageData(width, height);
                const data = imageData.data;

                const scale = 3.5 / (this.zoom * width);
                const chunkSize = 20; // Update progress every 20 rows

                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const zx = this.centerX + (px - width / 2) * scale;
                        const zy = this.centerY + (py - height / 2) * scale;

                        const iteration = this.julia(zx, zy);
                        const [r, g, b] = this.getColor(iteration);

                        const index = (py * width + px) * 4;
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                        data[index + 3] = 255;
                    }

                    // Update progress but DON'T draw to canvas yet
                    if (py % chunkSize === 0) {
                        const progress = (py / height) * 100;
                        this.updateProgress(progress);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                this.updateProgress(100);
                // Draw complete image all at once
                this.ctx.putImageData(imageData, 0, 0);
            }

            renderKoch() {
                const depth = Math.min(Math.floor(this.maxIterations / 20), 7);
                const points = this.generateKochSnowflake(depth);

                // Transform points to screen coordinates
                this.ctx.strokeStyle = '#00BFFF';
                this.ctx.lineWidth = 1.5;
                this.ctx.lineJoin = 'round';
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                
                for (let i = 0; i < points.length; i++) {
                    const [wx, wy] = points[i];
                    const sx = this.worldToScreenX(wx);
                    const sy = this.worldToScreenY(wy);

                    if (i === 0) {
                        this.ctx.moveTo(sx, sy);
                    } else {
                        this.ctx.lineTo(sx, sy);
                    }
                }

                this.ctx.closePath();
                this.ctx.stroke();

                // Fill the snowflake
                this.ctx.fillStyle = 'rgba(0, 191, 255, 0.1)';
                this.ctx.fill();
            }

            renderSierpinski() {
                const depth = Math.min(Math.floor(this.maxIterations / 20), 10);
                const triangles = this.generateSierpinskiTriangle(depth);

                // Draw all triangles
                this.ctx.fillStyle = '#FF1493';
                this.ctx.strokeStyle = '#FF69B4';
                this.ctx.lineWidth = 0.5;

                for (const triangle of triangles) {
                    this.ctx.beginPath();
                    
                    for (let i = 0; i < triangle.length; i++) {
                        const [wx, wy] = triangle[i];
                        const sx = this.worldToScreenX(wx);
                        const sy = this.worldToScreenY(wy);

                        if (i === 0) {
                            this.ctx.moveTo(sx, sy);
                        } else {
                            this.ctx.lineTo(sx, sy);
                        }
                    }

                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }

            renderDragon() {
                const depth = Math.min(Math.floor(this.maxIterations / 10), 16);
                const points = this.generateDragonCurve(depth);

                this.ctx.strokeStyle = '#FFD700';
                this.ctx.lineWidth = 2;
                this.ctx.lineJoin = 'round';
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                
                for (let i = 0; i < points.length; i++) {
                    const [wx, wy] = points[i];
                    const sx = this.worldToScreenX(wx);
                    const sy = this.worldToScreenY(wy);

                    if (i === 0) {
                        this.ctx.moveTo(sx, sy);
                    } else {
                        this.ctx.lineTo(sx, sy);
                    }
                }

                this.ctx.stroke();
            }

            renderBarnsley() {
                const iterations = Math.min(this.maxIterations * 1000, 100000);
                const points = this.generateBarnsleyFern(iterations);

                this.ctx.fillStyle = '#00FF00';
                
                for (const [wx, wy] of points) {
                    const sx = this.worldToScreenX(wx);
                    const sy = this.worldToScreenY(wy);
                    
                    this.ctx.fillRect(sx, sy, 1, 1);
                }
            }

            renderMenger() {
                const depth = Math.min(Math.floor(this.maxIterations / 25), 5);
                const squares = this.generateMengerSponge(depth);

                this.ctx.fillStyle = '#9370DB';
                this.ctx.strokeStyle = '#8A2BE2';
                this.ctx.lineWidth = 1;

                for (const square of squares) {
                    const x1 = this.worldToScreenX(square.x - square.size / 2);
                    const y1 = this.worldToScreenY(square.y - square.size / 2);
                    const x2 = this.worldToScreenX(square.x + square.size / 2);
                    const y2 = this.worldToScreenY(square.y + square.size / 2);
                    
                    const width = x2 - x1;
                    const height = y2 - y1;

                    this.ctx.fillRect(x1, y1, width, height);
                    this.ctx.strokeRect(x1, y1, width, height);
                }
            }

            worldToScreenX(worldX) {
                const scale = this.zoom * this.canvas.width / 3.5;
                return (worldX - this.centerX) * scale + this.canvas.width / 2;
            }

            worldToScreenY(worldY) {
                const scale = this.zoom * this.canvas.width / 3.5;
                return (worldY - this.centerY) * scale + this.canvas.height / 2;
            }
        }

        // Initialize the viewer when page loads
        window.addEventListener('load', () => {
            new FractalViewer();
        });
    </script>
</body>
</html>
