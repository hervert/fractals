<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .menu {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            z-index: 1000;
        }

        .menu h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #333;
        }

        .menu-section {
            margin-bottom: 15px;
        }

        .menu-section:last-child {
            margin-bottom: 0;
        }

        .menu-section label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .menu-section select,
        .menu-section input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        button {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: 500;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #2196F3;
        }

        button.secondary:hover {
            background: #0b7dda;
        }

        button.active {
            background: #7B1FA2;
            box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.3);
        }

        .info {
            font-size: 11px;
            color: #888;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            min-width: 250px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .loading.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-top: 12px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 4px;
        }

        .progress-text {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="menu">
        <h2>Fractal Viewer</h2>
        
        <div class="menu-section">
            <label>Fractal Type</label>
            <select id="fractalType">
                <option value="mandelbrot">Mandelbrot Set</option>
                <option value="burning_ship">Burning Ship</option>
                <option value="julia">Julia Set</option>
                <option value="koch">Koch Snowflake</option>
                <option value="sierpinski">Sierpinski Triangle</option>
                <option value="dragon">Dragon Curve</option>
                <option value="barnsley">Barnsley Fern</option>
                <option value="menger">Menger Sponge</option>
            </select>
        </div>

        <div class="menu-section" id="juliaControls" style="display: none;">
            <label>Julia Set Preset</label>
            <select id="juliaPreset">
                <option value="dendrite">Dendrite (-0.4 + 0.6i)</option>
                <option value="san_marco">San Marco (-0.75 + 0.1i)</option>
                <option value="spiral">Spiral (-0.7269 + 0.1889i)</option>
                <option value="dragon">Dragon (-0.835 - 0.2321i)</option>
                <option value="douady">Douady Rabbit (-0.123 + 0.745i)</option>
                <option value="siegel">Siegel Disk (-0.391 - 0.587i)</option>
                <option value="custom">Custom Parameters</option>
            </select>
            
            <button id="juliaClickBtn" style="width: 100%; margin-top: 10px; background: #9C27B0;">
                Click Mandelbrot to Set Julia
            </button>
        </div>

        <div class="menu-section" id="mandelbrotControls" style="display: none;">
            <button id="mandelbrotClickBtn" style="width: 100%; background: #9C27B0;">
                Click to Pick Julia Parameter
            </button>
            <div id="clickModeIndicator" style="display: none; margin-top: 8px; padding: 8px; background: rgba(156, 39, 176, 0.1); border-radius: 4px; font-size: 11px; color: #9C27B0; text-align: center;">
                Click anywhere on the fractal
            </div>
        </div>

        <div class="menu-section" id="juliaParams" style="display: none;">
            <label>Real Part (c_real)</label>
            <input type="number" id="juliaReal" value="-0.8" step="0.001" min="-2" max="2">
            <label style="margin-top: 8px;">Imaginary Part (c_imag)</label>
            <input type="number" id="juliaImag" value="0.156" step="0.001" min="-2" max="2">
        </div>

        <div class="menu-section">
            <label>Max Iterations</label>
            <input type="number" id="maxIterations" value="100" min="10" max="1000" step="10">
        </div>

        <div class="menu-section">
            <label>Color Scheme</label>
            <select id="colorScheme">
                <option value="default">Default (Polynomial)</option>
                <option value="cosine">Cosine Gradient (Custom)</option>
                <option value="continuous">Continuous (HSL)</option>
                <option value="hsl">HSL Interpolation</option>
                <option value="golden">Golden Ratio</option>
                <option value="cubehelix">Cubehelix</option>
                <option value="grayscale">Grayscale</option>
                <option value="bezier">Bezier RGB</option>
                <option value="complementary">Complementary</option>
                <option value="triadic">Triadic</option>
                <option value="stripe">Stripe Averaging</option>
            </select>
        </div>

        <div class="menu-section" id="cosineControls" style="display: none;">
            <label style="margin-bottom: 10px; display: block;">Base Color</label>
            <div style="display: flex; gap: 8px; align-items: center;">
                <input type="color" id="cosineBaseColor" value="#8080ff" style="flex: 1; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                <div id="cosineBasePreview" style="width: 35px; height: 35px; border-radius: 4px; background: #8080ff; border: 2px solid #ddd;"></div>
            </div>
            
            <label style="margin-top: 12px; margin-bottom: 10px; display: block;">Accent Color</label>
            <div style="display: flex; gap: 8px; align-items: center;">
                <input type="color" id="cosineAccentColor" value="#ff8080" style="flex: 1; height: 35px; border: none; border-radius: 4px; cursor: pointer;">
                <div id="cosineAccentPreview" style="width: 35px; height: 35px; border-radius: 4px; background: #ff8080; border: 2px solid #ddd;"></div>
            </div>
        </div>

        <div class="menu-section" id="hslControls" style="display: none;">
            <label>Start Hue (0-360°)</label>
            <input type="range" id="hslStartHue" min="0" max="360" value="240" style="width: 100%;">
            <span id="hslStartHueValue" style="font-size: 11px; color: #666;">240°</span>
            
            <label style="margin-top: 8px;">End Hue (0-360°)</label>
            <input type="range" id="hslEndHue" min="0" max="360" value="0" style="width: 100%;">
            <span id="hslEndHueValue" style="font-size: 11px; color: #666;">0°</span>
        </div>

        <div class="menu-section" id="bezierControls" style="display: none;">
            <label style="margin-bottom: 8px; display: block;">Color Points</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <div>
                    <label style="font-size: 10px; color: #666;">Start</label>
                    <div style="display: flex; gap: 4px;">
                        <input type="color" id="bezierColor0" value="#0a1464" style="flex: 1; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                        <div id="bezierPreview0" style="width: 30px; height: 30px; border-radius: 4px; background: #0a1464; border: 1px solid #ddd;"></div>
                    </div>
                </div>
                <div>
                    <label style="font-size: 10px; color: #666;">Point 1</label>
                    <div style="display: flex; gap: 4px;">
                        <input type="color" id="bezierColor1" value="#0096c8" style="flex: 1; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                        <div id="bezierPreview1" style="width: 30px; height: 30px; border-radius: 4px; background: #0096c8; border: 1px solid #ddd;"></div>
                    </div>
                </div>
                <div>
                    <label style="font-size: 10px; color: #666;">Point 2</label>
                    <div style="display: flex; gap: 4px;">
                        <input type="color" id="bezierColor2" value="#ffdc32" style="flex: 1; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                        <div id="bezierPreview2" style="width: 30px; height: 30px; border-radius: 4px; background: #ffdc32; border: 1px solid #ddd;"></div>
                    </div>
                </div>
                <div>
                    <label style="font-size: 10px; color: #666;">End</label>
                    <div style="display: flex; gap: 4px;">
                        <input type="color" id="bezierColor3" value="#c8320a" style="flex: 1; height: 30px; border: none; border-radius: 4px; cursor: pointer;">
                        <div id="bezierPreview3" style="width: 30px; height: 30px; border-radius: 4px; background: #c8320a; border: 1px solid #ddd;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="menu-section" id="complementaryControls" style="display: none;">
            <label>Base Hue (0-360°)</label>
            <input type="range" id="complementaryHue" min="0" max="360" value="220" style="width: 100%;">
            <span id="complementaryHueValue" style="font-size: 11px; color: #666;">220°</span>
        </div>

        <div class="menu-section" id="triadicControls" style="display: none;">
            <label>Base Hue (0-360°)</label>
            <input type="range" id="triadicHue" min="0" max="360" value="0" style="width: 100%;">
            <span id="triadicHueValue" style="font-size: 11px; color: #666;">0°</span>
        </div>

        <div class="menu-section" id="cubehelixControls" style="display: none;">
            <label>Rotations</label>
            <input type="range" id="cubehelixRotations" min="-3" max="3" step="0.1" value="-1.5" style="width: 100%;">
            <span id="cubehelixRotationsValue" style="font-size: 11px; color: #666;">-1.5</span>
        </div>

        <div class="button-group">
            <button id="resetBtn" class="secondary">Reset View</button>
            <button id="renderBtn">Render</button>
        </div>

        <div class="info">
            Left-click and drag to zoom box<br>
            Right-click and drag to pan<br>
            Scroll to zoom<br>
            Double-click to zoom in
        </div>
    </div>

    <div class="loading" id="loading">
        <div id="loadingText">Rendering...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">0%</div>
    </div>

    <script>
        class FractalViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.progressFill = document.getElementById('progressFill');
                this.progressText = document.getElementById('progressText');
                
                // Fractal parameters
                this.fractalType = 'mandelbrot';
                this.centerX = -0.5;
                this.centerY = 0;
                this.zoom = 1;
                this.maxIterations = 100;
                this.colorScheme = 'default';
                
                // Multi-resolution rendering
                this.useMultiRes = true;
                this.currentRenderPass = 0;
                this.renderPasses = [
                    { scale: 4, iterations: 0.25 },  // 1/4 resolution, 1/4 iterations
                    { scale: 2, iterations: 0.5 },   // 1/2 resolution, 1/2 iterations
                    { scale: 1, iterations: 1.0 }    // Full resolution, full iterations
                ];
                
                // Click-to-Julia mode
                this.juliaClickMode = false;
                
                // Cosine gradient colors
                this.cosineBaseColor = { r: 128, g: 128, b: 255 }; // Purple-blue
                this.cosineAccentColor = { r: 255, g: 128, b: 128 }; // Pink-red
                
                // HSL parameters
                this.hslStartHue = 240;
                this.hslEndHue = 0;
                
                // Bezier parameters
                this.bezierColors = [
                    { r: 10, g: 20, b: 100 },
                    { r: 0, g: 150, b: 200 },
                    { r: 255, g: 220, b: 50 },
                    { r: 200, g: 50, b: 10 }
                ];
                
                // Complementary/Triadic base hues
                this.complementaryHue = 220;
                this.triadicHue = 0;
                
                // Cubehelix rotations
                this.cubehelixRotations = -1.5;
                
                // Julia Set parameters
                this.juliaReal = -0.4;
                this.juliaImag = 0.6;
                
                // Julia Set presets
                this.juliaPresets = {
                    dendrite: { real: -0.4, imag: 0.6, name: 'Dendrite' },
                    san_marco: { real: -0.75, imag: 0.1, name: 'San Marco' },
                    spiral: { real: -0.7269, imag: 0.1889, name: 'Spiral' },
                    dragon: { real: -0.835, imag: -0.2321, name: 'Dragon' },
                    douady: { real: -0.123, imag: 0.745, name: 'Douady Rabbit' },
                    siegel: { real: -0.391, imag: -0.587, name: 'Siegel Disk' }
                };
                
                // Mouse interaction
                this.isDragging = false;
                this.isZoomBoxing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.zoomBoxStart = { x: 0, y: 0 };
                this.zoomBoxEnd = { x: 0, y: 0 };
                this.savedImageData = null; // For storing canvas state during zoom box
                
                // Debounce timers for color controls
                this.colorDebounceTimer = null;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.render();
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.render();
                });

                // Mouse dragging for panning and zoom box
                this.canvas.addEventListener('mousedown', (e) => {
                    // Right-click or Ctrl+Click for panning
                    if (e.button === 2 || e.ctrlKey) {
                        e.preventDefault();
                        this.isDragging = true;
                        this.lastX = e.clientX;
                        this.lastY = e.clientY;
                    } 
                    // Left-click for zoom box or Julia parameter selection
                    else if (e.button === 0 && !e.ctrlKey) {
                        // Check if in Julia click mode
                        if (this.juliaClickMode && this.fractalType === 'mandelbrot') {
                            this.handleJuliaClick(e.clientX, e.clientY);
                        } else {
                            this.isZoomBoxing = true;
                            this.zoomBoxStart.x = e.clientX;
                            this.zoomBoxStart.y = e.clientY;
                            this.zoomBoxEnd.x = e.clientX;
                            this.zoomBoxEnd.y = e.clientY;
                            // Save current canvas state
                            this.savedImageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                        }
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const dx = e.clientX - this.lastX;
                        const dy = e.clientY - this.lastY;
                        
                        const scale = 3.5 / (this.zoom * this.canvas.width);
                        this.centerX -= dx * scale;
                        this.centerY -= dy * scale;
                        
                        this.lastX = e.clientX;
                        this.lastY = e.clientY;
                        
                        this.render();
                    } else if (this.isZoomBoxing) {
                        this.zoomBoxEnd.x = e.clientX;
                        this.zoomBoxEnd.y = e.clientY;
                        // Restore saved image and draw zoom box
                        this.ctx.putImageData(this.savedImageData, 0, 0);
                        this.drawZoomBox();
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.isZoomBoxing && e.button === 0) {
                        this.isZoomBoxing = false;
                        this.savedImageData = null;
                        this.executeZoomBox();
                    }
                    this.isDragging = false;
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    if (this.isZoomBoxing) {
                        // Restore canvas if zoom box was cancelled
                        if (this.savedImageData) {
                            this.ctx.putImageData(this.savedImageData, 0, 0);
                        }
                        this.isZoomBoxing = false;
                        this.savedImageData = null;
                    }
                });

                // Prevent context menu on right-click
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // Mouse wheel for zooming
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    
                    // Get world coordinates before zoom
                    const worldX = this.screenToWorldX(mouseX);
                    const worldY = this.screenToWorldY(mouseY);
                    
                    // Zoom
                    this.zoom *= zoomFactor;
                    
                    // Get world coordinates after zoom
                    const newWorldX = this.screenToWorldX(mouseX);
                    const newWorldY = this.screenToWorldY(mouseY);
                    
                    // Adjust center to keep mouse position fixed
                    this.centerX += worldX - newWorldX;
                    this.centerY += worldY - newWorldY;
                    
                    this.render();
                });

                // Double-click to zoom in
                this.canvas.addEventListener('dblclick', (e) => {
                    const worldX = this.screenToWorldX(e.clientX);
                    const worldY = this.screenToWorldY(e.clientY);
                    
                    this.centerX = worldX;
                    this.centerY = worldY;
                    this.zoom *= 2;
                    
                    this.render();
                });

                // Menu controls
                document.getElementById('fractalType').addEventListener('change', (e) => {
                    this.fractalType = e.target.value;
                    this.updateJuliaControls();
                    this.updateCosineControls();
                    this.resetView();
                    this.render();
                });

                // Julia click mode buttons
                const mandelbrotClickBtn = document.getElementById('mandelbrotClickBtn');
                const juliaClickBtn = document.getElementById('juliaClickBtn');
                const clickModeIndicator = document.getElementById('clickModeIndicator');

                if (mandelbrotClickBtn) {
                    mandelbrotClickBtn.addEventListener('click', () => {
                        this.juliaClickMode = !this.juliaClickMode;
                        if (this.juliaClickMode) {
                            mandelbrotClickBtn.classList.add('active');
                            mandelbrotClickBtn.textContent = 'Click Mode: ON';
                            clickModeIndicator.style.display = 'block';
                        } else {
                            mandelbrotClickBtn.classList.remove('active');
                            mandelbrotClickBtn.textContent = 'Click to Pick Julia Parameter';
                            clickModeIndicator.style.display = 'none';
                        }
                    });
                }

                if (juliaClickBtn) {
                    juliaClickBtn.addEventListener('click', () => {
                        // Switch to Mandelbrot and enable click mode
                        this.fractalType = 'mandelbrot';
                        document.getElementById('fractalType').value = 'mandelbrot';
                        this.juliaClickMode = true;
                        this.updateJuliaControls();
                        this.resetView();
                        this.render();
                    });
                }

                document.getElementById('juliaPreset').addEventListener('change', (e) => {
                    const preset = e.target.value;
                    if (preset !== 'custom' && this.juliaPresets[preset]) {
                        this.juliaReal = this.juliaPresets[preset].real;
                        this.juliaImag = this.juliaPresets[preset].imag;
                        document.getElementById('juliaReal').value = this.juliaReal;
                        document.getElementById('juliaImag').value = this.juliaImag;
                        document.getElementById('juliaParams').style.display = 'none';
                    } else {
                        document.getElementById('juliaParams').style.display = 'block';
                    }
                    this.render();
                });

                document.getElementById('juliaReal').addEventListener('input', (e) => {
                    this.juliaReal = parseFloat(e.target.value);
                    document.getElementById('juliaPreset').value = 'custom';
                });
                document.getElementById('juliaReal').addEventListener('change', (e) => {
                    this.render();
                });

                document.getElementById('juliaImag').addEventListener('input', (e) => {
                    this.juliaImag = parseFloat(e.target.value);
                    document.getElementById('juliaPreset').value = 'custom';
                });
                document.getElementById('juliaImag').addEventListener('change', (e) => {
                    this.render();
                });

                document.getElementById('maxIterations').addEventListener('change', (e) => {
                    this.maxIterations = parseInt(e.target.value);
                });

                document.getElementById('colorScheme').addEventListener('change', (e) => {
                    this.colorScheme = e.target.value;
                    this.updateCosineControls();
                    this.render();
                });

                document.getElementById('cosineBaseColor').addEventListener('input', (e) => {
                    const hex = e.target.value;
                    this.cosineBaseColor = this.hexToRgb(hex);
                    document.getElementById('cosineBasePreview').style.background = hex;
                    this.debouncedRender();
                });

                document.getElementById('cosineAccentColor').addEventListener('input', (e) => {
                    const hex = e.target.value;
                    this.cosineAccentColor = this.hexToRgb(hex);
                    document.getElementById('cosineAccentPreview').style.background = hex;
                    this.debouncedRender();
                });

                // HSL controls
                document.getElementById('hslStartHue').addEventListener('input', (e) => {
                    this.hslStartHue = parseInt(e.target.value);
                    document.getElementById('hslStartHueValue').textContent = this.hslStartHue + '°';
                });
                document.getElementById('hslStartHue').addEventListener('change', (e) => {
                    this.render();
                });

                document.getElementById('hslEndHue').addEventListener('input', (e) => {
                    this.hslEndHue = parseInt(e.target.value);
                    document.getElementById('hslEndHueValue').textContent = this.hslEndHue + '°';
                });
                document.getElementById('hslEndHue').addEventListener('change', (e) => {
                    this.render();
                });

                // Bezier controls
                for (let i = 0; i < 4; i++) {
                    document.getElementById(`bezierColor${i}`).addEventListener('input', (e) => {
                        this.bezierColors[i] = this.hexToRgb(e.target.value);
                        document.getElementById(`bezierPreview${i}`).style.background = e.target.value;
                        this.debouncedRender();
                    });
                }

                // Complementary control
                document.getElementById('complementaryHue').addEventListener('input', (e) => {
                    this.complementaryHue = parseInt(e.target.value);
                    document.getElementById('complementaryHueValue').textContent = this.complementaryHue + '°';
                });
                document.getElementById('complementaryHue').addEventListener('change', (e) => {
                    this.render();
                });

                // Triadic control
                document.getElementById('triadicHue').addEventListener('input', (e) => {
                    this.triadicHue = parseInt(e.target.value);
                    document.getElementById('triadicHueValue').textContent = this.triadicHue + '°';
                });
                document.getElementById('triadicHue').addEventListener('change', (e) => {
                    this.render();
                });

                // Cubehelix control
                document.getElementById('cubehelixRotations').addEventListener('input', (e) => {
                    this.cubehelixRotations = parseFloat(e.target.value);
                    document.getElementById('cubehelixRotationsValue').textContent = this.cubehelixRotations.toFixed(1);
                });
                document.getElementById('cubehelixRotations').addEventListener('change', (e) => {
                    this.render();
                });

                document.getElementById('renderBtn').addEventListener('click', () => {
                    this.render();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetView();
                    this.render();
                });
            }

            updateJuliaControls() {
                const juliaControls = document.getElementById('juliaControls');
                const juliaParams = document.getElementById('juliaParams');
                const mandelbrotControls = document.getElementById('mandelbrotControls');
                const mandelbrotClickBtn = document.getElementById('mandelbrotClickBtn');
                const clickModeIndicator = document.getElementById('clickModeIndicator');
                
                if (this.fractalType === 'julia') {
                    juliaControls.style.display = 'block';
                    mandelbrotControls.style.display = 'none';
                    // Show params only if custom is selected
                    const preset = document.getElementById('juliaPreset').value;
                    juliaParams.style.display = preset === 'custom' ? 'block' : 'none';
                } else if (this.fractalType === 'mandelbrot') {
                    juliaControls.style.display = 'none';
                    mandelbrotControls.style.display = 'block';
                    // Update button state
                    if (this.juliaClickMode) {
                        mandelbrotClickBtn.classList.add('active');
                        mandelbrotClickBtn.textContent = 'Click Mode: ON';
                        clickModeIndicator.style.display = 'block';
                    } else {
                        mandelbrotClickBtn.classList.remove('active');
                        mandelbrotClickBtn.textContent = 'Click to Pick Julia Parameter';
                        clickModeIndicator.style.display = 'none';
                    }
                } else {
                    juliaControls.style.display = 'none';
                    juliaParams.style.display = 'none';
                    mandelbrotControls.style.display = 'none';
                }
            }

            updateCosineControls() {
                // Hide all color control sections
                document.getElementById('cosineControls').style.display = 'none';
                document.getElementById('hslControls').style.display = 'none';
                document.getElementById('bezierControls').style.display = 'none';
                document.getElementById('complementaryControls').style.display = 'none';
                document.getElementById('triadicControls').style.display = 'none';
                document.getElementById('cubehelixControls').style.display = 'none';
                
                // Show relevant controls based on scheme
                switch(this.colorScheme) {
                    case 'cosine':
                        document.getElementById('cosineControls').style.display = 'block';
                        break;
                    case 'hsl':
                        document.getElementById('hslControls').style.display = 'block';
                        break;
                    case 'bezier':
                        document.getElementById('bezierControls').style.display = 'block';
                        break;
                    case 'complementary':
                        document.getElementById('complementaryControls').style.display = 'block';
                        break;
                    case 'triadic':
                        document.getElementById('triadicControls').style.display = 'block';
                        break;
                    case 'cubehelix':
                        document.getElementById('cubehelixControls').style.display = 'block';
                        break;
                }
            }

            handleJuliaClick(screenX, screenY) {
                // Convert screen coordinates to Mandelbrot coordinates
                const worldX = this.screenToWorldX(screenX);
                const worldY = this.screenToWorldY(screenY);
                
                // Set Julia parameters to clicked point
                this.juliaReal = worldX;
                this.juliaImag = worldY;
                
                // Update UI
                document.getElementById('juliaReal').value = this.juliaReal.toFixed(4);
                document.getElementById('juliaImag').value = this.juliaImag.toFixed(4);
                document.getElementById('juliaPreset').value = 'custom';
                
                // Switch to Julia set
                this.fractalType = 'julia';
                document.getElementById('fractalType').value = 'julia';
                
                // Disable click mode
                this.juliaClickMode = false;
                
                // Update UI and render
                this.updateJuliaControls();
                this.resetView();
                this.render();
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 128, g: 128, b: 255 };
            }

            debouncedRender(delay = 150) {
                // Clear existing timer
                if (this.colorDebounceTimer) {
                    clearTimeout(this.colorDebounceTimer);
                }
                // Set new timer
                this.colorDebounceTimer = setTimeout(() => {
                    this.render();
                }, delay);
            }

            updateProgress(percent) {
                this.progressFill.style.width = percent + '%';
                this.progressText.textContent = Math.floor(percent) + '%';
            }

            resetView() {
                if (this.fractalType === 'mandelbrot') {
                    this.centerX = -0.5;
                    this.centerY = 0;
                    this.zoom = 1;
                } else if (this.fractalType === 'burning_ship') {
                    this.centerX = -0.5;
                    this.centerY = -0.5;
                    this.zoom = 1.2;
                } else if (this.fractalType === 'julia') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                } else if (this.fractalType === 'koch') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                } else if (this.fractalType === 'sierpinski') {
                    this.centerX = 0;
                    this.centerY = 0.1;
                    this.zoom = 1.8;
                } else if (this.fractalType === 'dragon') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 2.5;
                } else if (this.fractalType === 'barnsley') {
                    this.centerX = 0;
                    this.centerY = -0.2;
                    this.zoom = 1.2;
                } else if (this.fractalType === 'menger') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                }
            }

            drawZoomBox() {
                // Draw the zoom box overlay without re-rendering the fractal
                const x1 = Math.min(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                const y1 = Math.min(this.zoomBoxStart.y, this.zoomBoxEnd.y);
                const width = Math.abs(this.zoomBoxEnd.x - this.zoomBoxStart.x);
                const height = Math.abs(this.zoomBoxEnd.y - this.zoomBoxStart.y);

                // Just draw the box overlay directly on top of existing canvas
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeRect(x1, y1, width, height);
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.fillRect(x1, y1, width, height);
                
                this.ctx.setLineDash([]);
            }

            executeZoomBox() {
                const x1 = Math.min(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                const y1 = Math.min(this.zoomBoxStart.y, this.zoomBoxEnd.y);
                const x2 = Math.max(this.zoomBoxStart.x, this.zoomBoxEnd.x);
                const y2 = Math.max(this.zoomBoxStart.y, this.zoomBoxEnd.y);

                const width = x2 - x1;
                const height = y2 - y1;

                // Ignore very small boxes (likely accidental clicks)
                if (width < 10 || height < 10) {
                    this.render();
                    return;
                }

                // Calculate the center of the zoom box in world coordinates
                const centerScreenX = (x1 + x2) / 2;
                const centerScreenY = (y1 + y2) / 2;
                
                const newCenterX = this.screenToWorldX(centerScreenX);
                const newCenterY = this.screenToWorldY(centerScreenY);

                // Calculate the zoom factor based on the box size
                const zoomFactorX = this.canvas.width / width;
                const zoomFactorY = this.canvas.height / height;
                const zoomFactor = Math.min(zoomFactorX, zoomFactorY);

                // Update view
                this.centerX = newCenterX;
                this.centerY = newCenterY;
                this.zoom *= zoomFactor;

                this.render();
            }

            screenToWorldX(screenX) {
                const scale = 3.5 / (this.zoom * this.canvas.width);
                return this.centerX + (screenX - this.canvas.width / 2) * scale;
            }

            screenToWorldY(screenY) {
                const scale = 3.5 / (this.zoom * this.canvas.width);
                return this.centerY + (screenY - this.canvas.height / 2) * scale;
            }

            mandelbrot(cx, cy) {
                let x = 0;
                let y = 0;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < this.maxIterations) {
                    const xtemp = x * x - y * y + cx;
                    y = 2 * x * y + cy;
                    x = xtemp;
                    iteration++;
                }

                // For continuous coloring, add smooth component
                if (iteration < this.maxIterations) {
                    const log_zn = Math.log(x * x + y * y) / 2;
                    const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                    iteration = iteration + 1 - nu;
                }

                return iteration;
            }

            julia(zx, zy) {
                let x = zx;
                let y = zy;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < this.maxIterations) {
                    const xtemp = x * x - y * y + this.juliaReal;
                    y = 2 * x * y + this.juliaImag;
                    x = xtemp;
                    iteration++;
                }

                // For continuous coloring, add smooth component
                if (iteration < this.maxIterations) {
                    const log_zn = Math.log(x * x + y * y) / 2;
                    const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                    iteration = iteration + 1 - nu;
                }

                return iteration;
            }

            getColor(iteration) {
                if (iteration >= this.maxIterations) {
                    return [0, 0, 0];
                }

                switch(this.colorScheme) {
                    case 'default':
                        return this.getColorDefault(iteration);
                    case 'cosine':
                        return this.getColorCosine(iteration);
                    case 'continuous':
                        return this.getColorContinuous(iteration);
                    case 'hsl':
                        return this.getColorHSL(iteration);
                    case 'golden':
                        return this.getColorGolden(iteration);
                    case 'cubehelix':
                        return this.getColorCubehelix(iteration);
                    case 'grayscale':
                        return this.getColorGrayscale(iteration);
                    case 'bezier':
                        return this.getColorBezier(iteration);
                    case 'complementary':
                        return this.getColorComplementary(iteration);
                    case 'triadic':
                        return this.getColorTriadic(iteration);
                    case 'stripe':
                        return this.getColorStripe(iteration);
                    default:
                        return this.getColorDefault(iteration);
                }
            }

            getColorDefault(iteration) {
                // Original polynomial coloring
                const t = iteration / this.maxIterations;
                const r = Math.floor(9 * (1 - t) * t * t * t * 255);
                const g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
                const b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);
                return [r, g, b];
            }

            getColorCosine(iteration) {
                // Cosine gradient using user-selected base and accent colors
                const t = iteration / this.maxIterations;
                
                // Convert user colors to normalized values (0-1 range)
                const base = {
                    r: this.cosineBaseColor.r / 255,
                    g: this.cosineBaseColor.g / 255,
                    b: this.cosineBaseColor.b / 255
                };
                
                const accent = {
                    r: this.cosineAccentColor.r / 255,
                    g: this.cosineAccentColor.g / 255,
                    b: this.cosineAccentColor.b / 255
                };
                
                // Calculate midpoint and amplitude for cosine function
                // a = midpoint between base and accent
                // b = half the distance between them (amplitude)
                const a = [
                    (base.r + accent.r) / 2,
                    (base.g + accent.g) / 2,
                    (base.b + accent.b) / 2
                ];
                
                const b = [
                    (accent.r - base.r) / 2,
                    (accent.g - base.g) / 2,
                    (accent.b - base.b) / 2
                ];
                
                // Use cosine function with configurable frequency
                const c = [1.0, 1.0, 1.0]; // Frequency
                const d = [0.0, 0.33, 0.67]; // Phase shift for each channel

                const r = Math.floor(255 * (a[0] + b[0] * Math.cos(2 * Math.PI * (c[0] * t + d[0]))));
                const g = Math.floor(255 * (a[1] + b[1] * Math.cos(2 * Math.PI * (c[1] * t + d[1]))));
                const b_val = Math.floor(255 * (a[2] + b[2] * Math.cos(2 * Math.PI * (c[2] * t + d[2]))));

                return [
                    Math.max(0, Math.min(255, r)),
                    Math.max(0, Math.min(255, g)),
                    Math.max(0, Math.min(255, b_val))
                ];
            }

            getColorContinuous(iteration) {
                // Continuous coloring using smooth iteration count
                // Slower hue cycling and modulated saturation/lightness for smoother appearance
                
                // Slow down the hue change significantly
                const hue = (iteration * 3) % 360;
                
                // Vary saturation and lightness based on iteration for depth
                // This creates more organic, less jarring transitions
                const saturation = 70 + 30 * Math.sin(iteration * 0.1);
                const lightness = 40 + 20 * Math.cos(iteration * 0.15);
                
                return this.hslToRgb(hue, saturation, lightness);
            }

            hslToRgb(h, s, l) {
                h = h / 360;
                s = s / 100;
                l = l / 100;

                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            getColorHSL(iteration) {
                // HSL interpolation with customizable start and end hues
                const t = iteration / this.maxIterations;
                const hue = this.hslStartHue + (this.hslEndHue - this.hslStartHue) * t;
                const saturation = 80;
                const lightness = 50;
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorGolden(iteration) {
                // Golden ratio based hue distribution
                const phi = 1.618033988749895; // Golden ratio
                const hue = (iteration * phi * 137.508) % 360; // Golden angle
                const saturation = 70;
                const lightness = 50;
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorCubehelix(iteration) {
                // Cubehelix color scheme with customizable rotations
                const t = iteration / this.maxIterations;
                const start = 0.5; // Start hue
                const hue = 360 * (start / 3 + this.cubehelixRotations * t);
                const saturation = 50 + 50 * t;
                const lightness = 20 + 60 * t; // Monotonically increasing
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorGrayscale(iteration) {
                // Simple grayscale with smooth gradation
                const t = iteration / this.maxIterations;
                const intensity = Math.floor(255 * Math.sqrt(t));
                return [intensity, intensity, intensity];
            }

            getColorBezier(iteration) {
                // Bezier curve interpolation through customizable RGB control points
                const t = iteration / this.maxIterations;
                
                const p0 = this.bezierColors[0];
                const p1 = this.bezierColors[1];
                const p2 = this.bezierColors[2];
                const p3 = this.bezierColors[3];

                // Cubic Bezier interpolation
                const s = 1 - t;
                const r = s*s*s * p0.r + 3*s*s*t * p1.r + 3*s*t*t * p2.r + t*t*t * p3.r;
                const g = s*s*s * p0.g + 3*s*s*t * p1.g + 3*s*t*t * p2.g + t*t*t * p3.g;
                const b = s*s*s * p0.b + 3*s*s*t * p1.b + 3*s*t*t * p2.b + t*t*t * p3.b;

                return [Math.floor(r), Math.floor(g), Math.floor(b)];
            }

            getColorComplementary(iteration) {
                // Complementary color harmony with customizable base hue
                const t = iteration / this.maxIterations;
                // Oscillate between complementary colors
                const hue = t < 0.5 ? this.complementaryHue : (this.complementaryHue + 180) % 360;
                const saturation = 80;
                const lightness = 40 + 20 * Math.sin(t * Math.PI * 4);
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorTriadic(iteration) {
                // Triadic color harmony with customizable base hue
                const t = iteration / this.maxIterations;
                let hue;
                if (t < 0.33) {
                    hue = this.triadicHue;
                } else if (t < 0.66) {
                    hue = (this.triadicHue + 120) % 360;
                } else {
                    hue = (this.triadicHue + 240) % 360;
                }
                const saturation = 70;
                const lightness = 45 + 15 * Math.sin(t * Math.PI * 6);
                return this.hslToRgb(hue, saturation, lightness);
            }

            getColorStripe(iteration) {
                // Stripe averaging effect - creates interesting banding
                const t = iteration / this.maxIterations;
                // Create color bands with smooth transitions
                const bands = 8;
                const bandIndex = Math.floor(t * bands);
                const bandT = (t * bands) - bandIndex;
                
                const hue = (bandIndex * 45) % 360;
                const saturation = 70 + 20 * Math.sin(bandT * Math.PI);
                const lightness = 40 + 20 * bandT;
                
                return this.hslToRgb(hue, saturation, lightness);
            }

            // Koch Snowflake methods
            kochSegment(x1, y1, x2, y2, depth) {
                if (depth === 0) {
                    return [[x1, y1], [x2, y2]];
                }

                const dx = x2 - x1;
                const dy = y2 - y1;

                // First third point
                const px1 = x1 + dx / 3;
                const py1 = y1 + dy / 3;

                // Second third point
                const px2 = x1 + 2 * dx / 3;
                const py2 = y1 + 2 * dy / 3;

                // Peak point (equilateral triangle)
                const angle = Math.PI / 3; // 60 degrees
                const px3 = px1 + (px2 - px1) * Math.cos(angle) - (py2 - py1) * Math.sin(angle);
                const py3 = py1 + (px2 - px1) * Math.sin(angle) + (py2 - py1) * Math.cos(angle);

                // Recursively generate segments
                const seg1 = this.kochSegment(x1, y1, px1, py1, depth - 1);
                const seg2 = this.kochSegment(px1, py1, px3, py3, depth - 1);
                const seg3 = this.kochSegment(px3, py3, px2, py2, depth - 1);
                const seg4 = this.kochSegment(px2, py2, x2, y2, depth - 1);

                // Concatenate all segments
                const result = seg1.slice(0, -1)
                    .concat(seg2.slice(0, -1))
                    .concat(seg3.slice(0, -1))
                    .concat(seg4);

                return result;
            }

            generateKochSnowflake(depth) {
                // Equilateral triangle vertices
                const size = 0.8;
                const height = size * Math.sqrt(3) / 2;
                
                const v1 = [-size / 2, height / 3];
                const v2 = [size / 2, height / 3];
                const v3 = [0, -2 * height / 3];

                // Generate each side of the snowflake
                const side1 = this.kochSegment(v1[0], v1[1], v2[0], v2[1], depth);
                const side2 = this.kochSegment(v2[0], v2[1], v3[0], v3[1], depth);
                const side3 = this.kochSegment(v3[0], v3[1], v1[0], v1[1], depth);

                // Concatenate all sides
                return side1.slice(0, -1)
                    .concat(side2.slice(0, -1))
                    .concat(side3.slice(0, -1));
            }

            // Sierpinski Triangle methods
            generateSierpinskiTriangle(depth) {
                const triangles = [];
                const size = 0.8;
                const height = size * Math.sqrt(3) / 2;

                // Initial triangle
                const v1 = [-size / 2, height / 3];
                const v2 = [size / 2, height / 3];
                const v3 = [0, -2 * height / 3];

                this.subdivideTriangle(v1, v2, v3, depth, triangles);
                return triangles;
            }

            subdivideTriangle(v1, v2, v3, depth, triangles) {
                if (depth === 0) {
                    triangles.push([v1, v2, v3]);
                    return;
                }

                // Midpoints
                const m1 = [(v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2];
                const m2 = [(v2[0] + v3[0]) / 2, (v2[1] + v3[1]) / 2];
                const m3 = [(v3[0] + v1[0]) / 2, (v3[1] + v1[1]) / 2];

                // Recursively subdivide the three outer triangles
                this.subdivideTriangle(v1, m1, m3, depth - 1, triangles);
                this.subdivideTriangle(m1, v2, m2, depth - 1, triangles);
                this.subdivideTriangle(m3, m2, v3, depth - 1, triangles);
            }

            // Dragon Curve methods
            generateDragonCurve(depth) {
                let sequence = [1]; // Start with a single right turn
                
                // Build the dragon curve sequence
                for (let i = 0; i < depth; i++) {
                    const newSequence = [...sequence];
                    newSequence.push(1); // Add a right turn
                    // Add reversed and flipped sequence
                    for (let j = sequence.length - 1; j >= 0; j--) {
                        newSequence.push(-sequence[j]);
                    }
                    sequence = newSequence;
                }

                // Convert sequence to points
                const points = [[0, 0]];
                let x = 0, y = 0;
                let direction = 0; // 0 = right, 1 = up, 2 = left, 3 = down
                const stepSize = 0.4 / Math.pow(Math.sqrt(2), depth);

                for (const turn of sequence) {
                    direction = (direction + turn + 4) % 4;
                    
                    switch (direction) {
                        case 0: x += stepSize; break; // right
                        case 1: y -= stepSize; break; // up
                        case 2: x -= stepSize; break; // left
                        case 3: y += stepSize; break; // down
                    }
                    
                    points.push([x, y]);
                }

                return points;
            }

            // Barnsley Fern methods
            generateBarnsleyFern(iterations) {
                const points = [];
                let x = 0, y = 0;

                for (let i = 0; i < iterations; i++) {
                    const r = Math.random();
                    let nextX, nextY;

                    if (r < 0.01) {
                        // Stem
                        nextX = 0;
                        nextY = 0.16 * y;
                    } else if (r < 0.86) {
                        // Successively smaller leaflets
                        nextX = 0.85 * x + 0.04 * y;
                        nextY = -0.04 * x + 0.85 * y + 1.6;
                    } else if (r < 0.93) {
                        // Largest left-hand leaflet
                        nextX = 0.2 * x - 0.26 * y;
                        nextY = 0.23 * x + 0.22 * y + 1.6;
                    } else {
                        // Largest right-hand leaflet
                        nextX = -0.15 * x + 0.28 * y;
                        nextY = 0.26 * x + 0.24 * y + 0.44;
                    }

                    x = nextX;
                    y = nextY;

                    // Skip first few iterations (transient behavior)
                    if (i > 20) {
                        points.push([x / 11, y / 11 - 0.5]); // Normalize to fit view
                    }
                }

                return points;
            }

            // Menger Sponge methods (2D cross-section)
            generateMengerSponge(depth) {
                const squares = [];
                this.subdivideMengerSquare(0, 0, 0.8, depth, squares);
                return squares;
            }

            subdivideMengerSquare(x, y, size, depth, squares) {
                if (depth === 0) {
                    squares.push({ x, y, size });
                    return;
                }

                const newSize = size / 3;

                // Divide into 9 squares, skip the middle one
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        // Skip center square
                        if (i === 1 && j === 1) continue;

                        const newX = x + (i - 1) * newSize;
                        const newY = y + (j - 1) * newSize;
                        this.subdivideMengerSquare(newX, newY, newSize, depth - 1, squares);
                    }
                }
            }

            async render() {
                this.loading.classList.add('active');
                this.updateProgress(0);
                
                // Small delay to allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));

                const width = this.canvas.width;
                const height = this.canvas.height;

                // Don't clear canvas - keep previous fractal visible while rendering

                if (this.fractalType === 'mandelbrot' || this.fractalType === 'julia' || this.fractalType === 'burning_ship') {
                    // Use multi-resolution rendering for computational fractals
                    await this.renderMultiRes();
                } else if (this.fractalType === 'koch') {
                    // Clear for geometric fractals
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderKoch();
                    this.updateProgress(100);
                } else if (this.fractalType === 'sierpinski') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderSierpinski();
                    this.updateProgress(100);
                } else if (this.fractalType === 'dragon') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderDragon();
                    this.updateProgress(100);
                } else if (this.fractalType === 'barnsley') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderBarnsley();
                    this.updateProgress(100);
                } else if (this.fractalType === 'menger') {
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, width, height);
                    this.updateProgress(50);
                    this.renderMenger();
                    this.updateProgress(100);
                }

                this.loading.classList.remove('active');
            }

            async renderMultiRes() {
                // Progressive multi-resolution rendering
                const totalPasses = this.renderPasses.length;
                
                for (let passIndex = 0; passIndex < totalPasses; passIndex++) {
                    const pass = this.renderPasses[passIndex];
                    const passProgress = passIndex / totalPasses;
                    
                    if (this.fractalType === 'mandelbrot') {
                        await this.renderMandelbrotPass(pass, passProgress);
                    } else if (this.fractalType === 'burning_ship') {
                        await this.renderBurningShipPass(pass, passProgress);
                    } else if (this.fractalType === 'julia') {
                        await this.renderJuliaPass(pass, passProgress);
                    }
                }
            }

            async renderMandelbrotPass(pass, baseProgress) {
                const fullWidth = this.canvas.width;
                const fullHeight = this.canvas.height;
                const scale = pass.scale;
                const width = Math.floor(fullWidth / scale);
                const height = Math.floor(fullHeight / scale);
                
                const imageData = this.ctx.createImageData(width, height);
                const data = imageData.data;

                const worldScale = 3.5 / (this.zoom * fullWidth);
                const iterations = Math.floor(this.maxIterations * pass.iterations);
                const chunkSize = 10;

                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const screenX = px * scale + scale / 2;
                        const screenY = py * scale + scale / 2;
                        const x0 = this.centerX + (screenX - fullWidth / 2) * worldScale;
                        const y0 = this.centerY + (screenY - fullHeight / 2) * worldScale;

                        const iteration = this.mandelbrotWithIterations(x0, y0, iterations);
                        const [r, g, b] = this.getColorWithIterations(iteration, iterations);

                        const index = (py * width + px) * 4;
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                        data[index + 3] = 255;
                    }

                    if (py % chunkSize === 0) {
                        const passProgressPct = (py / height) * (1.0 / this.renderPasses.length);
                        const totalProgress = (baseProgress + passProgressPct) * 100;
                        this.updateProgress(totalProgress);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // Scale up and draw to canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imageData, 0, 0);
                
                this.ctx.imageSmoothingEnabled = scale > 1;
                this.ctx.drawImage(tempCanvas, 0, 0, fullWidth, fullHeight);
            }

            async renderJuliaPass(pass, baseProgress) {
                const fullWidth = this.canvas.width;
                const fullHeight = this.canvas.height;
                const scale = pass.scale;
                const width = Math.floor(fullWidth / scale);
                const height = Math.floor(fullHeight / scale);
                
                const imageData = this.ctx.createImageData(width, height);
                const data = imageData.data;

                const worldScale = 3.5 / (this.zoom * fullWidth);
                const iterations = Math.floor(this.maxIterations * pass.iterations);
                const chunkSize = 10;

                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const screenX = px * scale + scale / 2;
                        const screenY = py * scale + scale / 2;
                        const zx = this.centerX + (screenX - fullWidth / 2) * worldScale;
                        const zy = this.centerY + (screenY - fullHeight / 2) * worldScale;

                        const iteration = this.juliaWithIterations(zx, zy, iterations);
                        const [r, g, b] = this.getColorWithIterations(iteration, iterations);

                        const index = (py * width + px) * 4;
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                        data[index + 3] = 255;
                    }

                    if (py % chunkSize === 0) {
                        const passProgressPct = (py / height) * (1.0 / this.renderPasses.length);
                        const totalProgress = (baseProgress + passProgressPct) * 100;
                        this.updateProgress(totalProgress);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // Scale up and draw to canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imageData, 0, 0);
                
                this.ctx.imageSmoothingEnabled = scale > 1;
                this.ctx.drawImage(tempCanvas, 0, 0, fullWidth, fullHeight);
            }

            burningShipWithIterations(cx, cy, maxIter) {
                let x = 0;
                let y = 0;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < maxIter) {
                    // Key difference: take absolute value before squaring
                    const xtemp = x * x - y * y + cx;
                    y = Math.abs(2 * x * y) + cy;
                    x = Math.abs(xtemp);
                    iteration++;
                }

                // For continuous coloring
                if (iteration < maxIter) {
                    const log_zn = Math.log(x * x + y * y) / 2;
                    const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                    iteration = iteration + 1 - nu;
                }

                return iteration;
            }

            async renderBurningShipPass(pass, baseProgress) {
                const fullWidth = this.canvas.width;
                const fullHeight = this.canvas.height;
                const scale = pass.scale;
                const width = Math.floor(fullWidth / scale);
                const height = Math.floor(fullHeight / scale);
                
                const imageData = this.ctx.createImageData(width, height);
                const data = imageData.data;

                const worldScale = 3.5 / (this.zoom * fullWidth);
                const iterations = Math.floor(this.maxIterations * pass.iterations);
                const chunkSize = 10;

                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const screenX = px * scale + scale / 2;
                        const screenY = py * scale + scale / 2;
                        const x0 = this.centerX + (screenX - fullWidth / 2) * worldScale;
                        const y0 = this.centerY + (screenY - fullHeight / 2) * worldScale;

                        const iteration = this.burningShipWithIterations(x0, y0, iterations);
                        const [r, g, b] = this.getColorWithIterations(iteration, iterations);

                        const index = (py * width + px) * 4;
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                        data[index + 3] = 255;
                    }

                    if (py % chunkSize === 0) {
                        const passProgressPct = (py / height) * (1.0 / this.renderPasses.length);
                        const totalProgress = (baseProgress + passProgressPct) * 100;
                        this.updateProgress(totalProgress);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // Scale up and draw to canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imageData, 0, 0);
                
                this.ctx.imageSmoothingEnabled = scale > 1;
                this.ctx.drawImage(tempCanvas, 0, 0, fullWidth, fullHeight);
            }

            mandelbrotWithIterations(cx, cy, maxIter) {
                let x = 0;
                let y = 0;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < maxIter) {
                    const xtemp = x * x - y * y + cx;
                    y = 2 * x * y + cy;
                    x = xtemp;
                    iteration++;
                }

                // For continuous coloring, add smooth component
                if (iteration < maxIter) {
                    const log_zn = Math.log(x * x + y * y) / 2;
                    const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                    iteration = iteration + 1 - nu;
                }

                return iteration;
            }

            juliaWithIterations(zx, zy, maxIter) {
                let x = zx;
                let y = zy;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < maxIter) {
                    const xtemp = x * x - y * y + this.juliaReal;
                    y = 2 * x * y + this.juliaImag;
                    x = xtemp;
                    iteration++;
                }

                // For continuous coloring, add smooth component
                if (iteration < maxIter) {
                    const log_zn = Math.log(x * x + y * y) / 2;
                    const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                    iteration = iteration + 1 - nu;
                }

                return iteration;
            }

            getColorWithIterations(iteration, maxIter) {
                if (iteration >= maxIter) {
                    return [0, 0, 0];
                }

                const savedMax = this.maxIterations;
                this.maxIterations = maxIter;
                const color = this.getColor(iteration);
                this.maxIterations = savedMax;
                return color;
            }

            renderKoch() {
                const depth = Math.min(Math.floor(this.maxIterations / 20), 7);
                const points = this.generateKochSnowflake(depth);

                // Transform points to screen coordinates
                this.ctx.strokeStyle = '#00BFFF';
                this.ctx.lineWidth = 1.5;
                this.ctx.lineJoin = 'round';
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                
                for (let i = 0; i < points.length; i++) {
                    const [wx, wy] = points[i];
                    const sx = this.worldToScreenX(wx);
                    const sy = this.worldToScreenY(wy);

                    if (i === 0) {
                        this.ctx.moveTo(sx, sy);
                    } else {
                        this.ctx.lineTo(sx, sy);
                    }
                }

                this.ctx.closePath();
                this.ctx.stroke();

                // Fill the snowflake
                this.ctx.fillStyle = 'rgba(0, 191, 255, 0.1)';
                this.ctx.fill();
            }

            renderSierpinski() {
                const depth = Math.min(Math.floor(this.maxIterations / 20), 10);
                const triangles = this.generateSierpinskiTriangle(depth);

                // Draw all triangles
                this.ctx.fillStyle = '#FF1493';
                this.ctx.strokeStyle = '#FF69B4';
                this.ctx.lineWidth = 0.5;

                for (const triangle of triangles) {
                    this.ctx.beginPath();
                    
                    for (let i = 0; i < triangle.length; i++) {
                        const [wx, wy] = triangle[i];
                        const sx = this.worldToScreenX(wx);
                        const sy = this.worldToScreenY(wy);

                        if (i === 0) {
                            this.ctx.moveTo(sx, sy);
                        } else {
                            this.ctx.lineTo(sx, sy);
                        }
                    }

                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }

            renderDragon() {
                const depth = Math.min(Math.floor(this.maxIterations / 10), 16);
                const points = this.generateDragonCurve(depth);

                this.ctx.strokeStyle = '#FFD700';
                this.ctx.lineWidth = 2;
                this.ctx.lineJoin = 'round';
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                
                for (let i = 0; i < points.length; i++) {
                    const [wx, wy] = points[i];
                    const sx = this.worldToScreenX(wx);
                    const sy = this.worldToScreenY(wy);

                    if (i === 0) {
                        this.ctx.moveTo(sx, sy);
                    } else {
                        this.ctx.lineTo(sx, sy);
                    }
                }

                this.ctx.stroke();
            }

            renderBarnsley() {
                const iterations = Math.min(this.maxIterations * 1000, 100000);
                const points = this.generateBarnsleyFern(iterations);

                this.ctx.fillStyle = '#00FF00';
                
                for (const [wx, wy] of points) {
                    const sx = this.worldToScreenX(wx);
                    const sy = this.worldToScreenY(wy);
                    
                    this.ctx.fillRect(sx, sy, 1, 1);
                }
            }

            renderMenger() {
                const depth = Math.min(Math.floor(this.maxIterations / 25), 5);
                const squares = this.generateMengerSponge(depth);

                this.ctx.fillStyle = '#9370DB';
                this.ctx.strokeStyle = '#8A2BE2';
                this.ctx.lineWidth = 1;

                for (const square of squares) {
                    const x1 = this.worldToScreenX(square.x - square.size / 2);
                    const y1 = this.worldToScreenY(square.y - square.size / 2);
                    const x2 = this.worldToScreenX(square.x + square.size / 2);
                    const y2 = this.worldToScreenY(square.y + square.size / 2);
                    
                    const width = x2 - x1;
                    const height = y2 - y1;

                    this.ctx.fillRect(x1, y1, width, height);
                    this.ctx.strokeRect(x1, y1, width, height);
                }
            }

            worldToScreenX(worldX) {
                const scale = this.zoom * this.canvas.width / 3.5;
                return (worldX - this.centerX) * scale + this.canvas.width / 2;
            }

            worldToScreenY(worldY) {
                const scale = this.zoom * this.canvas.width / 3.5;
                return (worldY - this.centerY) * scale + this.canvas.height / 2;
            }
        }

        // Initialize the viewer when page loads
        window.addEventListener('load', () => {
            new FractalViewer();
        });
    </script>
</body>
</html>
