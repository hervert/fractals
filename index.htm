<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .menu {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            z-index: 1000;
        }

        .menu h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #333;
        }

        .menu-section {
            margin-bottom: 15px;
        }

        .menu-section:last-child {
            margin-bottom: 0;
        }

        .menu-section label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .menu-section select,
        .menu-section input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        button {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: 500;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #2196F3;
        }

        button.secondary:hover {
            background: #0b7dda;
        }

        .info {
            font-size: 11px;
            color: #888;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .loading.active {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="menu">
        <h2>Fractal Viewer</h2>
        
        <div class="menu-section">
            <label>Fractal Type</label>
            <select id="fractalType">
                <option value="mandelbrot">Mandelbrot Set</option>
                <option value="koch">Koch Snowflake</option>
                <option value="sierpinski">Sierpinski Triangle</option>
            </select>
        </div>

        <div class="menu-section">
            <label>Max Iterations</label>
            <input type="number" id="maxIterations" value="100" min="10" max="1000" step="10">
        </div>

        <div class="button-group">
            <button id="resetBtn" class="secondary">Reset View</button>
            <button id="renderBtn">Render</button>
        </div>

        <div class="info">
            Click and drag to pan<br>
            Scroll to zoom<br>
            Double-click to zoom in
        </div>
    </div>

    <div class="loading" id="loading">Rendering...</div>

    <script>
        class FractalViewer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                
                // Fractal parameters
                this.fractalType = 'mandelbrot';
                this.centerX = -0.5;
                this.centerY = 0;
                this.zoom = 1;
                this.maxIterations = 100;
                
                // Mouse interaction
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.render();
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.render();
                });

                // Mouse dragging for panning
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastX = e.clientX;
                    this.lastY = e.clientY;
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const dx = e.clientX - this.lastX;
                        const dy = e.clientY - this.lastY;
                        
                        const scale = 3.5 / (this.zoom * this.canvas.width);
                        this.centerX -= dx * scale;
                        this.centerY -= dy * scale;
                        
                        this.lastX = e.clientX;
                        this.lastY = e.clientY;
                        
                        this.render();
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                });

                // Mouse wheel for zooming
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    
                    // Get world coordinates before zoom
                    const worldX = this.screenToWorldX(mouseX);
                    const worldY = this.screenToWorldY(mouseY);
                    
                    // Zoom
                    this.zoom *= zoomFactor;
                    
                    // Get world coordinates after zoom
                    const newWorldX = this.screenToWorldX(mouseX);
                    const newWorldY = this.screenToWorldY(mouseY);
                    
                    // Adjust center to keep mouse position fixed
                    this.centerX += worldX - newWorldX;
                    this.centerY += worldY - newWorldY;
                    
                    this.render();
                });

                // Double-click to zoom in
                this.canvas.addEventListener('dblclick', (e) => {
                    const worldX = this.screenToWorldX(e.clientX);
                    const worldY = this.screenToWorldY(e.clientY);
                    
                    this.centerX = worldX;
                    this.centerY = worldY;
                    this.zoom *= 2;
                    
                    this.render();
                });

                // Menu controls
                document.getElementById('fractalType').addEventListener('change', (e) => {
                    this.fractalType = e.target.value;
                    this.resetView();
                    this.render();
                });

                document.getElementById('maxIterations').addEventListener('change', (e) => {
                    this.maxIterations = parseInt(e.target.value);
                });

                document.getElementById('renderBtn').addEventListener('click', () => {
                    this.render();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetView();
                    this.render();
                });
            }

            resetView() {
                if (this.fractalType === 'mandelbrot') {
                    this.centerX = -0.5;
                    this.centerY = 0;
                    this.zoom = 1;
                } else if (this.fractalType === 'koch') {
                    this.centerX = 0;
                    this.centerY = 0;
                    this.zoom = 1.5;
                } else if (this.fractalType === 'sierpinski') {
                    this.centerX = 0;
                    this.centerY = 0.1;
                    this.zoom = 1.8;
                }
            }

            screenToWorldX(screenX) {
                const scale = 3.5 / (this.zoom * this.canvas.width);
                return this.centerX + (screenX - this.canvas.width / 2) * scale;
            }

            screenToWorldY(screenY) {
                const scale = 3.5 / (this.zoom * this.canvas.width);
                return this.centerY + (screenY - this.canvas.height / 2) * scale;
            }

            mandelbrot(cx, cy) {
                let x = 0;
                let y = 0;
                let iteration = 0;

                while (x * x + y * y <= 4 && iteration < this.maxIterations) {
                    const xtemp = x * x - y * y + cx;
                    y = 2 * x * y + cy;
                    x = xtemp;
                    iteration++;
                }

                return iteration;
            }

            getColor(iteration) {
                if (iteration === this.maxIterations) {
                    return [0, 0, 0];
                }

                // Smooth coloring using continuous iteration count
                const t = iteration / this.maxIterations;
                
                // Color palette: deep blues to bright cyans and purples
                const r = Math.floor(9 * (1 - t) * t * t * t * 255);
                const g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
                const b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);

                return [r, g, b];
            }

            // Koch Snowflake methods
            kochSegment(x1, y1, x2, y2, depth) {
                if (depth === 0) {
                    return [[x1, y1], [x2, y2]];
                }

                const dx = x2 - x1;
                const dy = y2 - y1;

                // First third point
                const px1 = x1 + dx / 3;
                const py1 = y1 + dy / 3;

                // Second third point
                const px2 = x1 + 2 * dx / 3;
                const py2 = y1 + 2 * dy / 3;

                // Peak point (equilateral triangle)
                const angle = Math.PI / 3; // 60 degrees
                const px3 = px1 + (px2 - px1) * Math.cos(angle) - (py2 - py1) * Math.sin(angle);
                const py3 = py1 + (px2 - px1) * Math.sin(angle) + (py2 - py1) * Math.cos(angle);

                // Recursively generate segments
                const seg1 = this.kochSegment(x1, y1, px1, py1, depth - 1);
                const seg2 = this.kochSegment(px1, py1, px3, py3, depth - 1);
                const seg3 = this.kochSegment(px3, py3, px2, py2, depth - 1);
                const seg4 = this.kochSegment(px2, py2, x2, y2, depth - 1);

                // Concatenate all segments
                const result = seg1.slice(0, -1)
                    .concat(seg2.slice(0, -1))
                    .concat(seg3.slice(0, -1))
                    .concat(seg4);

                return result;
            }

            generateKochSnowflake(depth) {
                // Equilateral triangle vertices
                const size = 0.8;
                const height = size * Math.sqrt(3) / 2;
                
                const v1 = [-size / 2, height / 3];
                const v2 = [size / 2, height / 3];
                const v3 = [0, -2 * height / 3];

                // Generate each side of the snowflake
                const side1 = this.kochSegment(v1[0], v1[1], v2[0], v2[1], depth);
                const side2 = this.kochSegment(v2[0], v2[1], v3[0], v3[1], depth);
                const side3 = this.kochSegment(v3[0], v3[1], v1[0], v1[1], depth);

                // Concatenate all sides
                return side1.slice(0, -1)
                    .concat(side2.slice(0, -1))
                    .concat(side3.slice(0, -1));
            }

            // Sierpinski Triangle methods
            generateSierpinskiTriangle(depth) {
                const triangles = [];
                const size = 0.8;
                const height = size * Math.sqrt(3) / 2;

                // Initial triangle
                const v1 = [-size / 2, height / 3];
                const v2 = [size / 2, height / 3];
                const v3 = [0, -2 * height / 3];

                this.subdivideTriangle(v1, v2, v3, depth, triangles);
                return triangles;
            }

            subdivideTriangle(v1, v2, v3, depth, triangles) {
                if (depth === 0) {
                    triangles.push([v1, v2, v3]);
                    return;
                }

                // Midpoints
                const m1 = [(v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2];
                const m2 = [(v2[0] + v3[0]) / 2, (v2[1] + v3[1]) / 2];
                const m3 = [(v3[0] + v1[0]) / 2, (v3[1] + v1[1]) / 2];

                // Recursively subdivide the three outer triangles
                this.subdivideTriangle(v1, m1, m3, depth - 1, triangles);
                this.subdivideTriangle(m1, v2, m2, depth - 1, triangles);
                this.subdivideTriangle(m3, m2, v3, depth - 1, triangles);
            }

            async render() {
                this.loading.classList.add('active');
                
                // Small delay to allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));

                const width = this.canvas.width;
                const height = this.canvas.height;

                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, width, height);

                if (this.fractalType === 'mandelbrot') {
                    this.renderMandelbrot();
                } else if (this.fractalType === 'koch') {
                    this.renderKoch();
                } else if (this.fractalType === 'sierpinski') {
                    this.renderSierpinski();
                }

                this.loading.classList.remove('active');
            }

            renderMandelbrot() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const imageData = this.ctx.createImageData(width, height);
                const data = imageData.data;

                const scale = 3.5 / (this.zoom * width);

                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const x0 = this.centerX + (px - width / 2) * scale;
                        const y0 = this.centerY + (py - height / 2) * scale;

                        const iteration = this.mandelbrot(x0, y0);
                        const [r, g, b] = this.getColor(iteration);

                        const index = (py * width + px) * 4;
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                        data[index + 3] = 255;
                    }
                }

                this.ctx.putImageData(imageData, 0, 0);
            }

            renderKoch() {
                const depth = Math.min(Math.floor(this.maxIterations / 20), 7);
                const points = this.generateKochSnowflake(depth);

                // Transform points to screen coordinates
                this.ctx.strokeStyle = '#00BFFF';
                this.ctx.lineWidth = 1.5;
                this.ctx.lineJoin = 'round';
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                
                for (let i = 0; i < points.length; i++) {
                    const [wx, wy] = points[i];
                    const sx = this.worldToScreenX(wx);
                    const sy = this.worldToScreenY(wy);

                    if (i === 0) {
                        this.ctx.moveTo(sx, sy);
                    } else {
                        this.ctx.lineTo(sx, sy);
                    }
                }

                this.ctx.closePath();
                this.ctx.stroke();

                // Fill the snowflake
                this.ctx.fillStyle = 'rgba(0, 191, 255, 0.1)';
                this.ctx.fill();
            }

            renderSierpinski() {
                const depth = Math.min(Math.floor(this.maxIterations / 20), 10);
                const triangles = this.generateSierpinskiTriangle(depth);

                // Draw all triangles
                this.ctx.fillStyle = '#FF1493';
                this.ctx.strokeStyle = '#FF69B4';
                this.ctx.lineWidth = 0.5;

                for (const triangle of triangles) {
                    this.ctx.beginPath();
                    
                    for (let i = 0; i < triangle.length; i++) {
                        const [wx, wy] = triangle[i];
                        const sx = this.worldToScreenX(wx);
                        const sy = this.worldToScreenY(wy);

                        if (i === 0) {
                            this.ctx.moveTo(sx, sy);
                        } else {
                            this.ctx.lineTo(sx, sy);
                        }
                    }

                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }

            worldToScreenX(worldX) {
                const scale = this.zoom * this.canvas.width / 3.5;
                return (worldX - this.centerX) * scale + this.canvas.width / 2;
            }

            worldToScreenY(worldY) {
                const scale = this.zoom * this.canvas.width / 3.5;
                return (worldY - this.centerY) * scale + this.canvas.height / 2;
            }
        }

        // Initialize the viewer when page loads
        window.addEventListener('load', () => {
            new FractalViewer();
        });
    </script>
</body>
</html>
